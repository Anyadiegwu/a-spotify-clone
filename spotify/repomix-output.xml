This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.js
index.html
package.json
public/vite.svg
README.md
server/.gitignore
server/index.js
src/api/index.js
src/api/spotify.js
src/App.css
src/App.jsx
src/assets/react.svg
src/components/loginpage/LoginPage.css
src/components/loginpage/LoginPage.jsx
src/components/maincontent/CurrentTrack.css
src/components/maincontent/CurrentTrack.jsx
src/components/maincontent/HomePage.css
src/components/maincontent/HomePage.jsx
src/components/maincontent/Library.css
src/components/maincontent/Library.jsx
src/components/maincontent/MainContent.css
src/components/maincontent/MainContent.jsx
src/components/maincontent/Search.css
src/components/maincontent/Search.jsx
src/components/player/GetTrackDetails.jsx
src/components/player/Player.css
src/components/player/Player.jsx
src/components/sidebar/Sidebar.css
src/components/sidebar/Sidebar.jsx
src/components/userdetails/LikedSongs.css
src/components/userdetails/LikedSongs.jsx
src/components/userdetails/Playlist.jsx
src/components/userdetails/PlayListView.jsx
src/index.css
src/main.jsx
vercel.json
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

.env
</file>

<file path="eslint.config.js">
// eslint.config.js
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';

export default [
  { ignores: ['dist/**', 'node_modules/**'] },

  {
    files: ['**/*.{jsx,tsx}', 'src/**/*.js'], 
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',
      globals: globals.browser,
      parserOptions: {
        ecmaFeatures: { jsx: true },
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      ...reactRefresh.configs.recommended.rules,
      'react-refresh/only-export-components': 'warn',
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },


  {
    files: ['index.js', 'server.js', 'api.js'], 
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',
      globals: {
        ...globals.node, 
      },
    },
    rules: {
      ...js.configs.recommended.rules,
      'no-console': 'off',          
      'no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    },
  },
];
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spotify</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "spotify",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "server": "cross-env HOST=127.0.0.1 node server/index.js",
    "vercel-build": "npm run build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "express-session": "^1.18.2",
    "lucide-react": "^0.562.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "cross-env": "^10.1.0",
    "dotenv": "^17.2.3",
    "eslint": "^9.39.2",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "express": "^5.2.1",
    "globals": "^16.5.0",
    "vite": "^7.2.4"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# Spotify Clone

A full-stack Spotify clone built with React, Node.js/Express, and the Spotify Web API. This application replicates core Spotify features including music playback control, playlist management, search functionality, and user library access.

![Spotify Clone](https://img.shields.io/badge/React-19.2.0-blue) ![Node.js](https://img.shields.io/badge/Node.js-Express-green) ![License](https://img.shields.io/badge/license-MIT-brightgreen)

---

## ğŸµ Features

### Core Functionality
- **ğŸ” Spotify Authentication** - Secure OAuth 2.0 login flow with token management
- **ğŸ§ Music Playback Control** - Play, pause, skip, previous, seek, and volume control
- **ğŸ“± Responsive Design** - Fully responsive UI that works on desktop, tablet, and mobile devices
- **ğŸ” Advanced Search** - Search for tracks, artists, albums, and playlists with real-time results
- **ğŸ“š Library Management** - Access and organize your playlists, liked songs, albums, and followed artists
- **ğŸ’š Like/Unlike Tracks** - Save and remove songs from your Liked Songs collection
- **ğŸ¨ Dynamic UI** - Beautiful gradients, smooth animations, and modern design patterns

### User Interface Components
- **Home Page** - Personalized recommendations with top tracks, artists, and recently played
- **Search Page** - Comprehensive search with filterable results
- **Library View** - Organized view of all your saved content
- **Playlist View** - Detailed playlist interface with track listings
- **Liked Songs** - Dedicated view for your favorite tracks
- **Music Player** - Full-featured bottom player with progress bar and controls

---

## ğŸ› ï¸ Tech Stack

### Frontend
- **React 19.2.0** - UI library with hooks
- **Vite 7.2.4** - Fast build tool and dev server
- **Lucide React** - Modern icon library
- **Axios** - HTTP client for API requests
- **CSS3** - Custom styling with CSS Grid and Flexbox

### Backend
- **Node.js** - JavaScript runtime
- **Express 5.2.1** - Web application framework
- **Spotify Web API** - Official Spotify API integration
- **CORS** - Cross-origin resource sharing
- **Cookie Parser** - Cookie handling middleware
- **Dotenv** - Environment variable management

### Development Tools
- **ESLint** - Code linting and quality
- **Vite Plugin React** - Fast refresh support
- **Cross-env** - Cross-platform environment variables

---

## ğŸ“‹ Prerequisites

Before you begin, ensure you have the following installed:
- **Node.js** (v16 or higher)
- **npm** or **yarn**
- **Spotify Premium Account** (required for playback control)
- **Spotify Developer Account** (to create an app and get API credentials)

---

## ğŸš€ Getting Started

### 1. Clone the Repository
```bash
git clone https://github.com/yourusername/spotify-clone.git
cd spotify-clone
```

### 2. Install Dependencies
```bash
npm install
```

### 3. Set Up Spotify Developer App

1. Go to [Spotify Developer Dashboard](https://developer.spotify.com/dashboard)
2. Create a new app
3. Add these redirect URIs in your app settings:
   ```
   http://127.0.0.1:5000/auth/callback
   http://localhost:5173
   ```
4. Note your **Client ID** and **Client Secret**

### 4. Configure Environment Variables

Create a `.env` file in the root directory:

```env
# Spotify API Credentials
SPOTIFY_CLIENT_ID=your_client_id_here
SPOTIFY_CLIENT_SECRET=your_client_secret_here

# Server Configuration
PORT=5000
REDIRECT_URI=http://127.0.0.1:5000/auth/callback
FRONTEND_URI=http://localhost:5173
```

### 5. Run the Application

#### Start the Backend Server
```bash
npm run server
```
The backend server will run on `http://127.0.0.1:5000`

#### Start the Frontend Development Server
Open a new terminal and run:
```bash
npm run dev
```
The frontend will run on `http://localhost:5173`

### 6. Login to Spotify
1. Navigate to `http://localhost:5173`
2. Click "Log in with Spotify"
3. Authorize the application
4. You'll be redirected back to the app, ready to use!

---

## ğŸ“ Project Structure

```
spotify-clone/
â”‚
â”œâ”€â”€ public/                    # Static assets
â”‚   â””â”€â”€ vite.svg
â”‚
â”œâ”€â”€ server/                    # Backend server
â”‚   â””â”€â”€ index.js              # Express server with Spotify API routes
â”‚
â”œâ”€â”€ src/                      # Frontend source code
â”‚   â”œâ”€â”€ api/                  # API integration
â”‚   â”‚   â””â”€â”€ spotify.js        # Spotify API wrapper functions
â”‚   â”‚
â”‚   â”œâ”€â”€ components/           # React components
â”‚   â”‚   â”œâ”€â”€ loginpage/        # Login screen
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginPage.jsx
â”‚   â”‚   â”‚   â””â”€â”€ LoginPage.css
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ sidebar/          # Navigation sidebar
â”‚   â”‚   â”‚   â”œâ”€â”€ Sidebar.jsx
â”‚   â”‚   â”‚   â””â”€â”€ Sidebar.css
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ maincontent/      # Main content area components
â”‚   â”‚   â”‚   â”œâ”€â”€ HomePage.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ HomePage.css
â”‚   â”‚   â”‚   â”œâ”€â”€ Search.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Search.css
â”‚   â”‚   â”‚   â”œâ”€â”€ Library.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Library.css
â”‚   â”‚   â”‚   â”œâ”€â”€ MainContent.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ MainContent.css
â”‚   â”‚   â”‚   â”œâ”€â”€ CurrentTrack.jsx
â”‚   â”‚   â”‚   â””â”€â”€ CurrentTrack.css
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ player/           # Music player components
â”‚   â”‚   â”‚   â”œâ”€â”€ Player.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Player.css
â”‚   â”‚   â”‚   â””â”€â”€ GetTrackDetails.jsx
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ userdetails/      # User-specific views
â”‚   â”‚       â”œâ”€â”€ LikedSongs.jsx
â”‚   â”‚       â”œâ”€â”€ LikedSongs.css
â”‚   â”‚       â”œâ”€â”€ Playlist.jsx
â”‚   â”‚       â””â”€â”€ PlayListView.jsx
â”‚   â”‚
â”‚   â”œâ”€â”€ assets/               # Static assets
â”‚   â”‚   â””â”€â”€ react.svg
â”‚   â”‚
â”‚   â”œâ”€â”€ App.jsx               # Main application component
â”‚   â”œâ”€â”€ App.css               # Global styles
â”‚   â”œâ”€â”€ main.jsx              # React entry point
â”‚   â””â”€â”€ index.css             # Base CSS
â”‚
â”œâ”€â”€ .env                      # Environment variables (create this)
â”œâ”€â”€ .gitignore               # Git ignore rules
â”œâ”€â”€ eslint.config.js         # ESLint configuration
â”œâ”€â”€ index.html               # HTML template
â”œâ”€â”€ package.json             # Dependencies and scripts
â”œâ”€â”€ README.md                # This file
â””â”€â”€ vite.config.js           # Vite configuration
```

---

## ğŸ”‘ Key Features Explained

### Authentication Flow
The app uses Spotify's OAuth 2.0 Authorization Code Flow:
1. User clicks "Login with Spotify"
2. Redirected to Spotify's authorization page
3. After approval, Spotify redirects back with an authorization code
4. Backend exchanges code for access and refresh tokens
5. Tokens are stored in localStorage for persistent sessions

### API Integration
All Spotify API calls are wrapped in helper functions in `src/api/spotify.js`:
- Automatic token refresh handling
- Error handling with user-friendly messages
- Request rate limiting and caching for search
- Abort controller support for cancellable requests

### Player Controls
The player component provides full playback control:
- Real-time progress tracking with seekable progress bar
- Volume control with visual feedback
- Previous/Next track navigation
- Play/Pause toggle
- Like/Unlike functionality
- Album art and track information display

### Search System
Advanced search features include:
- Debounced search input (500ms delay)
- Result caching to reduce API calls
- Filterable results (All, Songs, Artists, Albums, Playlists)
- Request cancellation on new searches
- Empty state and error handling

---

## ğŸ¨ Responsive Design

The application is fully responsive with breakpoints at:
- **Desktop**: 1024px and above
- **Tablet**: 768px - 1023px
- **Mobile**: 480px - 767px
- **Small Mobile**: Below 480px

Key responsive features:
- Collapsible sidebar to bottom navigation on mobile
- Scrolling track titles on smaller screens
- Touch-optimized controls
- Adaptive grid layouts
- Hidden columns on mobile for better readability

---

## ğŸ“¡ Available API Endpoints

### Authentication
- `GET /auth/login` - Initiate Spotify OAuth flow
- `GET /auth/callback` - Handle OAuth callback
- `POST /auth/refresh` - Refresh access token
- `GET /auth/logout` - Clear authentication cookies

### User Data
- `GET /api/me` - Get current user profile
- `GET /api/playlists` - Get user's playlists
- `GET /api/me/top/artists` - Get user's top artists
- `GET /api/me/top/tracks` - Get user's top tracks
- `GET /api/me/following` - Get followed artists
- `GET /api/me/player/recently-played` - Get recently played tracks

### Playback Control
- `GET /api/player` - Get current playback state
- `PUT /api/player/play` - Start playback of a track
- `PUT /api/player/toggle` - Toggle play/pause
- `POST /api/player/next` - Skip to next track
- `POST /api/player/previous` - Go to previous track
- `PUT /api/player/volume` - Set volume level
- `PUT /api/player/seek` - Seek to position in track

### Library Management
- `GET /api/library` - Get all library content
- `GET /api/library/liked-songs` - Get Liked Songs playlist info
- `GET /api/playlists/:playlistId/tracks` - Get tracks from a playlist
- `PUT /api/tracks/:id/like` - Like a track
- `DELETE /api/tracks/:id/like` - Unlike a track
- `GET /api/tracks/liked` - Check if tracks are liked

### Search & Discovery
- `GET /api/search` - Search for tracks, artists, albums, playlists
- `GET /api/browse/new-releases` - Get new album releases
- `GET /api/artists/:id` - Get artist details
- `GET /api/artists/:id/top-tracks` - Get artist's top tracks
- `GET /api/albums/:id` - Get album details

---

## ğŸ® Usage Guide

### Playing Music
1. Ensure you have an active Spotify device (desktop app, mobile app, or web player)
2. Navigate through Home, Search, or Library to find music
3. Click on any track to start playback
4. Use the player controls at the bottom to manage playback

### Managing Playlists
1. Click on "Your Library" in the sidebar
2. Filter by Playlists to see all your playlists
3. Click on any playlist to view its tracks
4. Click on tracks to play them

### Searching for Music
1. Click on the Search icon in the sidebar
2. Type your search query
3. Use the filter buttons (All, Songs, Artists, Albums, Playlists) to refine results
4. Click on any result to interact with it

### Managing Liked Songs
1. Click the heart icon on any track to like/unlike it
2. Access all your liked songs through "Liked Songs" in the sidebar
3. View your complete collection in a dedicated interface

---

## ğŸ”’ Security Considerations

- **Environment Variables**: Never commit `.env` file to version control
- **Token Storage**: Access tokens stored in localStorage (consider more secure alternatives for production)
- **CORS Configuration**: Restricted to specified frontend origin
- **HTTP-Only Cookies**: Used for state management in auth flow
- **Token Expiration**: Automatic refresh token handling

---

## âš ï¸ Known Limitations

1. **Spotify Premium Required**: Free accounts cannot control playback
2. **Active Device Needed**: Requires an active Spotify device to control playback
3. **Rate Limiting**: Spotify API has rate limits (respect them in production)
4. **Browser Storage**: Using localStorage instead of secure token storage
5. **No Offline Support**: Requires internet connection for all features

---

## ğŸ› Troubleshooting

### Issue: "No access token" error
**Solution**: 
- Clear browser localStorage
- Log out and log back in
- Check if your Spotify Developer App credentials are correct in `.env`

### Issue: Playback controls not working
**Solution**:
- Ensure you have a Spotify Premium account
- Open Spotify on any device to create an active session
- Check if the device is selected in the Spotify app

### Issue: "Failed to fetch player state"
**Solution**:
- Make sure Spotify is actively playing on at least one device
- Refresh the page to re-authenticate
- Check your internet connection

### Issue: Search not returning results
**Solution**:
- Check if your API credentials are valid
- Ensure you're not hitting Spotify's rate limits
- Try clearing the browser cache

### Issue: Backend server won't start
**Solution**:
- Verify all environment variables in `.env` are set correctly
- Check if port 5000 is already in use
- Run `npm install` to ensure all dependencies are installed

---

## ğŸš§ Future Enhancements

- [ ] Implement queue management
- [ ] Add playlist creation and editing
- [ ] Include podcast support
- [ ] Add lyrics integration
- [ ] Implement collaborative playlists
- [ ] Add social sharing features
- [ ] Create user profile management
- [ ] Implement audio visualization
- [ ] Add keyboard shortcuts
- [ ] Include shuffle and repeat controls
- [ ] Add download for offline playback (where permitted)
- [ ] Implement crossfade between tracks
- [ ] Add equalizer settings
- [ ] Create custom themes/skins
- [ ] Implement drag-and-drop playlist organization

---

## ğŸ¤ Contributing

Contributions are welcome! Please follow these steps:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

### Contribution Guidelines
- Follow the existing code style and conventions
- Write clear, descriptive commit messages
- Add comments to complex logic
- Update documentation as needed
- Test your changes thoroughly before submitting
- Ensure responsive design principles are maintained

---

## ğŸ“ License

This project is licensed under the MIT License - see the LICENSE file for details.

```
MIT License

Copyright (c) 2025 [Victor Anyadiegwu]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

---

## ğŸ™ Acknowledgments

- [Spotify Web API](https://developer.spotify.com/documentation/web-api) for the comprehensive API
- [Lucide Icons](https://lucide.dev/) for the beautiful icon set
- [Vite](https://vitejs.dev/) for the amazing developer experience
- [React](https://react.dev/) for the powerful UI library
- [Express.js](https://expressjs.com/) for the robust backend framework
- The React community for excellent documentation and resources
- All contributors who help improve this project

---

## ğŸ“§ Contact

For questions, issues, or suggestions:
- **GitHub Issues**: [Create an issue](https://github.com/yourusername/spotify-clone/issues)
- **Email**: your.email@example.com
- **Twitter**: [@yourhandle](https://twitter.com/yourhandle)

---

## ğŸ”— Useful Links

- [Spotify Web API Documentation](https://developer.spotify.com/documentation/web-api)
- [Spotify Web Playback SDK](https://developer.spotify.com/documentation/web-playback-sdk)
- [React Documentation](https://react.dev/)
- [Express.js Documentation](https://expressjs.com/)
- [Vite Documentation](https://vitejs.dev/)
- [OAuth 2.0 Documentation](https://oauth.net/2/)

---

## ğŸ“Š Project Stats

- **Lines of Code**: ~5,000+
- **Components**: 20+
- **API Endpoints**: 25+
- **Supported Devices**: Desktop, Tablet, Mobile
- **Build Time**: < 2 seconds (Vite)

---

## ğŸŒŸ Show Your Support

If you find this project helpful, please consider:
- â­ Starring the repository on GitHub
- ğŸ› Reporting bugs and issues
- ğŸ’¡ Suggesting new features
- ğŸ”€ Contributing code improvements
- ğŸ“¢ Sharing with others who might find it useful

---

**Made with â¤ï¸ and â˜• by [Victor Anyadiegwu]**

**â­ Don't forget to star this repository if you found it helpful!**
</file>

<file path="server/.gitignore">
.vercel
.env*.local
</file>

<file path="server/index.js">
import express from 'express';
import dotenv from 'dotenv';
import querystring from 'node:querystring';
import axios from 'axios';
import cors from 'cors';
import cookieParser from 'cookie-parser';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

const CLIENT_ID = process.env.SPOTIFY_CLIENT_ID;
const CLIENT_SECRET = process.env.SPOTIFY_CLIENT_SECRET;
const REDIRECT_URI = process.env.REDIRECT_URI || 'http://127.0.0.1:5000/auth/callback';
const FRONTEND_URI = process.env.FRONTEND_URI || "https://a-spotify-clone.vercel.app/";

let accessToken = '';
let tokenExpiresAt = 0;

async function getAccessToken() {
  if (Date.now() < tokenExpiresAt) {
    return accessToken;
  }

  try {
    const response = await axios({
      url: 'https://accounts.spotify.com/api/token',
      method: 'post',
      params: { grant_type: 'client_credentials' },
      headers: {
        'Authorization': 'Basic ' + Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64'),
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    });

    accessToken = response.data.access_token;
    tokenExpiresAt = Date.now() + response.data.expires_in * 1000 - 60000;
    return accessToken;
  } catch (error) {
    console.error('Failed to get client credentials token:', error.response?.data || error.message);
    throw error;
  }
}

// app.use(cors({
//   origin: FRONTEND_URI,
//   credentials: true,
// }));
app.use(cors({
  origin: [
    'http://localhost:5173', 
    'https://your-app-name.vercel.app',  
    process.env.FRONTEND_URI  
  ].filter(Boolean),
  credentials: true,
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

const generateRandomString = (length) => {
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let text = '';
  for (let i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
};


app.get('/auth/login', (req, res) => {
  const state = generateRandomString(16);
  
  res.cookie('spotify_auth_state', state, {
    httpOnly: true,
    maxAge: 5 * 60 * 1000, 
    sameSite: 'lax',
    secure: false,
    path: '/',
  });

  const scope = [
    'user-read-private',
    'user-read-email',
    'playlist-read-private',
    'playlist-modify-public',
    'playlist-modify-private',
    'user-read-playback-state',   
    'user-read-currently-playing',
    'user-modify-playback-state',
    'user-library-read',     
    'user-library-modify',
    'user-top-read',           
    'user-read-recently-played',  
    'user-follow-read',  
  ].join(' ');

  const params = new URLSearchParams({
    response_type: 'code',
    client_id: CLIENT_ID,
    scope,
    redirect_uri: REDIRECT_URI,
    state,
  });

  res.redirect(`https://accounts.spotify.com/authorize?${params.toString()}`);
});

app.get('/auth/callback', async (req, res) => {
  const code = req.query.code || null;
  const state = req.query.state || null;
  const storedState = req.cookies.spotify_auth_state;

 

  res.clearCookie('spotify_auth_state');

  if (!code || state !== storedState) {
    return res.redirect(`${FRONTEND_URI}?error=invalid_state`);
  }

  try {
    const tokenResponse = await axios({
      method: 'post',
      url: 'https://accounts.spotify.com/api/token',
      data: querystring.stringify({
        grant_type: 'authorization_code',
        code,
        redirect_uri: REDIRECT_URI,
      }),
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: `Basic ${Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64')}`,
      },
    });

    const { access_token, refresh_token, expires_in } = tokenResponse.data;

    const params = new URLSearchParams({
      access_token,
      refresh_token,
      expires_in,
    });

    res.redirect(`${FRONTEND_URI}#${params.toString()}`);
  } catch (error) {
    console.error('Token exchange failed:', error.response?.data || error.message);
    res.redirect(`${FRONTEND_URI}?error=token_exchange_failed`);
  }
});

app.get('/api/me', async (req, res) => {

  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;
  

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    const response = await axios.get('https://api.spotify.com/v1/me', {
      headers: { Authorization: `Bearer ${access_token}` },
    });
    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch user:', error.response?.data);
    res.status(401).json({ error: 'Failed to fetch user', details: error.response?.data });
  }
});

app.get('/api/playlists', async (req, res) => {
  
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;


  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    const response = await axios.get('https://api.spotify.com/v1/me/playlists?limit=50', {
      headers: { Authorization: `Bearer ${access_token}` },
    });
    res.json(response.data.items);
  } catch (error) {
    console.error('Failed to fetch playlists:', error.response?.data);
    res.status(500).json({ error: 'Failed to fetch playlists' });
  }
});

app.get('/api/playlists/:playlistId/tracks', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;
  
  const { playlistId } = req.params;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    let response;

    if (playlistId === 'liked-songs') {
      response = await axios.get('https://api.spotify.com/v1/me/tracks?limit=50', {
        headers: { Authorization: `Bearer ${access_token}` },
      });
      const transformed = {
        items: response.data.items.map(item => ({
          track: item.track,
          added_at: item.added_at,
        })),
        total: response.data.total,
        limit: response.data.limit,
        offset: response.data.offset,
      };
      return res.json(transformed);
    }


    response = await axios.get(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
      headers: { Authorization: `Bearer ${access_token}` },
    });

    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch playlist tracks:', error.response?.data);
    res.status(500).json({ error: 'Failed to fetch playlist tracks' });
  }
});

app.get('/api/player', async (req, res) => {
  
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    const response = await axios.get('https://api.spotify.com/v1/me/player', {
      headers: { Authorization: `Bearer ${access_token}` },
    });
    
    if (response.status === 204 || !response.data) {
      return res.json({ isPlaying: false, device: null, item: null });
    }

    res.json(response.data);
  } catch (error) {
    if (error.response && error.response.status === 204) {
      return res.json({ isPlaying: false, device: null, item: null });
    }
    console.error('Failed to fetch player state:', error.response?.data);
    res.status(500).json({ error: 'Failed to fetch player state', details: error.response?.data });
  }
});

app.post('/auth/refresh', async (req, res) => {
  const refresh_token = req.cookies.spotify_refresh_token;

  if (!refresh_token) {
    return res.status(400).json({ error: 'No refresh token available' });
  }

  try {
    const response = await axios({
      method: 'post',
      url: 'https://accounts.spotify.com/api/token',
      data: querystring.stringify({
        grant_type: 'refresh_token',
        refresh_token,
      }),
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: `Basic ${Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64')}`,
      },
    });

    const { access_token, expires_in } = response.data;
    
    res.cookie('spotify_access_token', access_token, {
      httpOnly: true,
      maxAge: expires_in * 1000,
      sameSite: 'lax',
      secure: false,
      path: '/',
    });

    res.json({ access_token });
  } catch (error) {
    console.error('Refresh failed:', error.response?.data || error.message);
    res.status(400).json({ error: 'Failed to refresh token' });
  }
});

app.put("/api/player/play", async (req, res) => {
  const { trackId } = req.body; 
  const accessToken = req.headers.authorization?.split(" ")[1];

  if (!accessToken) {
    return res.status(401).json({ error: "Missing access token" });
  }

  if (!trackId) {
    return res.status(400).json({ error: "Missing trackId or uri" });
  }

  try {

    const response = await axios.put(
      "https://api.spotify.com/v1/me/player/play",
      {
        uris: [`spotify:track:${trackId}`],
      },
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
      }
    );
    res.sendStatus(204);

  } catch (err) {
      console.error("Play track error:", err.response?.data || err.message);
      
      res.status(err.response?.status || 500).json({
        error: "Failed to play track",
        details: err.response?.data?.error?.message || err.message, // âœ… Fixed
        status: err.response?.status
      });
    }
});

app.put('/api/player/toggle', async (req, res) => {
  const accessToken = req.headers.authorization?.split(' ')[1];

  if (!accessToken) {
    return res.status(401).json({ error: 'Missing access token' });
  }

  try {
    const stateResponse = await axios.get(
      'https://api.spotify.com/v1/me/player',
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );

    const isPlaying = stateResponse.data?.is_playing;

    const endpoint = isPlaying
      ? 'https://api.spotify.com/v1/me/player/pause'
      : 'https://api.spotify.com/v1/me/player/play';

    await axios.put(
      endpoint,
      {},
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );

    return res.sendStatus(204);
  } catch (err) {
    const status = err.response?.status || 500;
    const message = err.response?.data?.error?.message || 'Failed to toggle playback';

    return res.status(status).json({
      error: 'Toggle failed',
      details: message,
    });
  }
});

app.post('/api/player/next', async (req, res) => {
  const accessToken = req.headers.authorization?.split(' ')[1];

  if (!accessToken) {
    return res.status(401).json({ error: 'Missing access token' });
  }

  try {
    await axios.post(
      'https://api.spotify.com/v1/me/player/next',
      {},
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      }
    );

    res.sendStatus(204); 
  } catch (err) {
    console.error('Next track error:', err.response?.data || err.message);

    const status = err.response?.status || 500;
    const message = err.response?.data?.error?.message || 'Failed to skip to next track';

    res.status(status).json({
      error: 'Failed to skip to next track',
      details: message,
    });
  }
});

app.post('/api/player/previous', async (req, res) => {
  const accessToken = req.headers.authorization?.split(' ')[1];

  if (!accessToken) {
    return res.status(401).json({ error: 'Missing access token' });
  }

  try {
    await axios.post(
      'https://api.spotify.com/v1/me/player/previous',
      {},
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      }
    );

    res.sendStatus(204);
  } catch (err) {
    console.error('Previous track error:', err.response?.data || err.message);

    const status = err.response?.status || 500;
    const message = err.response?.data?.error?.message || 'Failed to go to previous track';

    res.status(status).json({
      error: 'Failed to go to previous track',
      details: message,
    });
  }
});

app.put('/api/player/volume', async (req, res) => {
  const accessToken = req.headers.authorization?.split(' ')[1];
  const { volume } = req.body; // 0â€“100

  if (!accessToken) {
    return res.status(401).json({ error: 'Missing access token' });
  }

  if (typeof volume !== 'number' || volume < 0 || volume > 100) {
    return res.status(400).json({ error: 'Volume must be between 0 and 100' });
  }

  try {
    await axios.put(
      `https://api.spotify.com/v1/me/player/volume?volume_percent=${volume}`,
      {},
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );

    res.sendStatus(204);
  } catch (err) {
    const status = err.response?.status || 500;
    const message =
      err.response?.data?.error?.message || 'Failed to set volume';

    res.status(status).json({
      error: 'Volume change failed',
      details: message,
    });
  }
});


app.put('/api/tracks/:id/like', async (req, res) => {
  const { id: trackId } = req.params;
  const accessToken = req.headers.authorization?.split(' ')[1];

  if (!accessToken) {
    return res.status(401).json({ error: 'Missing access token' });
  }

  try {
    await axios.put(
      `https://api.spotify.com/v1/me/tracks`,
      { ids: [trackId] },
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      }
    );

    res.sendStatus(200); 
  } catch (err) {
    console.error('Like track error:', err.response?.data || err.message);
    const status = err.response?.status || 500;
    res.status(status).json({
      error: 'Failed to like track',
      details: err.response?.data?.error?.message || err.message,
    });
  }
});

app.delete('/api/tracks/:id/like', async (req, res) => {
  const { id: trackId } = req.params;
  const accessToken = req.headers.authorization?.split(' ')[1];

  if (!accessToken) {
    return res.status(401).json({ error: 'Missing access token' });
  }

  try {
    await axios.delete(
      `https://api.spotify.com/v1/me/tracks?ids=${trackId}`,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );

    res.sendStatus(200);
  } catch (err) {
    console.error('Unlike track error:', err.response?.data || err.message);
    const status = err.response?.status || 500;
    res.status(status).json({
      error: 'Failed to unlike track',
      details: err.response?.data?.error?.message || err.message,
    });
  }
});

app.get('/api/tracks/liked', async (req, res) => {
  const { ids } = req.query; 

  if (!ids) {
    return res.status(400).json({ error: 'Missing track ids' });
  }

  const accessToken = req.headers.authorization?.split(' ')[1];

  if (!accessToken) {
    return res.status(401).json({ error: 'Missing access token' });
  }

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/me/tracks/contains?ids=${ids}`,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );

    res.json(response.data);
  } catch (err) {
    console.error('Check liked error:', err.response?.data || err.message);
    const status = err.response?.status || 500;
    res.status(status).json({
      error: 'Failed to check liked tracks',
      details: err.response?.data?.error?.message || err.message,
    });
  }
});

app.put('/api/player/seek', async (req, res) => {
  const accessToken = req.headers.authorization?.split(' ')[1];
  const { position_ms } = req.body;

  if (!accessToken) {
    return res.status(401).json({ error: 'Missing access token' });
  }

  if (typeof position_ms !== 'number' || position_ms < 0) {
    return res.status(400).json({ error: 'Invalid position_ms' });
  }

  try {
    await axios.put(
      `https://api.spotify.com/v1/me/player/seek?position_ms=${Math.floor(position_ms)}`,
      {},
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      }
    );

    res.sendStatus(204);
  } catch (err) {
    console.error('Seek failed:', err.response?.data || err.message);
    const status = err.response?.status || 500;
    const message = err.response?.data?.error?.message || 'Failed to seek';

    res.status(status).json({ error: 'Seek failed', details: message });
  }
});

app.get('/api/me/top/artists', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const timeRange = req.query.time_range || 'medium_term';
  const limit = req.query.limit || 20;

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/me/top/artists?time_range=${timeRange}&limit=${limit}`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
      }
    );
    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch top artists:', error.response?.data);
    res.status(500).json({ 
      error: 'Failed to fetch top artists', 
      details: error.response?.data 
    });
  }
});

app.get('/api/me/top/tracks', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const timeRange = req.query.time_range || 'medium_term';
  const limit = req.query.limit || 20;

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/me/top/tracks?time_range=${timeRange}&limit=${limit}`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
      }
    );
    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch top tracks:', error.response?.data);
    res.status(500).json({ 
      error: 'Failed to fetch top tracks', 
      details: error.response?.data 
    });
  }
});

app.get('/api/me/following', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const limit = req.query.limit || 20;

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/me/following?type=artist&limit=${limit}`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
      }
    );
    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch followed artists:', error.response?.data);
    res.status(500).json({ 
      error: 'Failed to fetch followed artists', 
      details: error.response?.data 
    });
  }
});

app.get('/api/me/player/recently-played', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const limit = req.query.limit || 20;

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/me/player/recently-played?limit=${limit}`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
      }
    );
    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch recently played:', error.response?.data);
    res.status(500).json({ 
      error: 'Failed to fetch recently played', 
      details: error.response?.data 
    });
  }
});

app.get('/api/browse/new-releases', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const limit = req.query.limit || 20;

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/browse/new-releases?limit=${limit}`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
      }
    );
    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch new releases:', error.response?.data);
    res.status(500).json({ 
      error: 'Failed to fetch new releases', 
      details: error.response?.data 
    });
  }
});

app.get('/api/search', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const { q, type, limit } = req.query;

  if (!q || q.trim() === '') {
    return res.status(400).json({ error: 'Search query is required' });
  }

  // âœ… Sanitize query
  const sanitizedQuery = q.trim();
  
  const searchType = type || 'track,artist,album,playlist';
  const searchLimit = Math.min(parseInt(limit) || 20, 50); // âœ… Limit max to 50

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/search`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
        params: {
          q: sanitizedQuery,
          type: searchType,
          limit: searchLimit,
        },
      }
    );

    res.json(response.data);
  } catch (error) {
    console.error('Search failed:', error.response?.data);
    res.status(error.response?.status || 500).json({ 
      error: 'Search failed',
      details: error.response?.data?.error?.message || error.message
    });
  }
});

app.get('/api/artists/:id', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const { id } = req.params;

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/artists/${id}`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
      }
    );

    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch artist:', error.response?.data);
    res.status(500).json({ 
      error: 'Failed to fetch artist',
      details: error.response?.data 
    });
  }
});

app.get('/api/artists/:id/top-tracks', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const { id } = req.params;

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/artists/${id}/top-tracks`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
        params: {
          market: 'US',
        },
      }
    );

    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch artist top tracks:', error.response?.data);
    res.status(500).json({ 
      error: 'Failed to fetch artist top tracks',
      details: error.response?.data 
    });
  }
});

app.get('/api/albums/:id', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const { id } = req.params;

  try {
    const response = await axios.get(
      `https://api.spotify.com/v1/albums/${id}`,
      {
        headers: { Authorization: `Bearer ${access_token}` },
      }
    );

    res.json(response.data);
  } catch (error) {
    console.error('Failed to fetch album:', error.response?.data);
    res.status(500).json({ 
      error: 'Failed to fetch album',
      details: error.response?.data 
    });
  }
});

app.get('/api/library', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    const [playlistsRes, albumsRes, artistsRes, showsRes, likedRes] = await Promise.all([
      axios.get('https://api.spotify.com/v1/me/playlists?limit=50', { headers: { Authorization: `Bearer ${access_token}` } }),
      axios.get('https://api.spotify.com/v1/me/albums?limit=50', { headers: { Authorization: `Bearer ${access_token}` } }),
      axios.get('https://api.spotify.com/v1/me/following?type=artist&limit=50', { headers: { Authorization: `Bearer ${access_token}` } }),
      axios.get('https://api.spotify.com/v1/me/shows?limit=50', { headers: { Authorization: `Bearer ${access_token}` } }),
      axios.get('https://api.spotify.com/v1/me/tracks?limit=50', { headers: { Authorization: `Bearer ${access_token}` } }),
    ]);

    res.json({
      playlists: playlistsRes.data.items,
      albums: albumsRes.data.items.map(i => ({ ...i.album, added_at: i.added_at })),
      artists: artistsRes.data.artists.items,
      podcasts: showsRes.data.items.map(i => ({ ...i.show, added_at: i.added_at })),
      likedSongs: {
        name: "Liked Songs",
        id: "liked-songs",
        images: [{ url: "https://misc.scdn.co/liked-songs/liked-songs-300.png" }], // official image
        type: "playlist",
        owner: { display_name: "You" },
        tracks: { total: likedRes.data.total },
      },
    });
  } catch (error) {
    console.error('Failed to fetch library data:', error.response?.data || error.message);
    res.status(500).json({ error: 'Failed to load library' });
  }
});

app.get('/api/library/liked-songs', async (req, res) => {
  const authHeader = req.headers.authorization;
  const access_token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!access_token) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    const tracksResponse = await axios.get(
      'https://api.spotify.com/v1/me/tracks?limit=1',
      { headers: { Authorization: `Bearer ${access_token}` } }
    );

    const total = tracksResponse.data.total;

    const likedSongsPlaylist = {
      id: 'liked-songs',
      name: 'Liked Songs',
      description: 'Your favorite tracks',
      images: [
        { url: 'https://misc.scdn.co/liked-songs/liked-songs-300.png' },
        { url: 'https://misc.scdn.co/liked-songs/liked-songs-640.png' }
      ],
      owner: { display_name: 'You', id: 'you' },
      tracks: {
        total,
        href: 'https://api.spotify.com/v1/me/tracks'
      },
      type: 'playlist',
      public: false,
    };

    res.json(likedSongsPlaylist);
  } catch (error) {
    console.error('Failed to fetch Liked Songs info:', error.response?.data);
    res.status(500).json({ error: 'Failed to fetch Liked Songs' });
  }
});

app.get('/auth/logout', (req, res) => {
  res.clearCookie('spotify_access_token');
  res.clearCookie('spotify_refresh_token');
  res.redirect(FRONTEND_URI);
});

if (process.env.VERCEL !== '1') {
  app.listen(PORT, () => {
    console.log(`Backend server running on http://127.0.0.1:${PORT}`);
    console.log(`Login URL: http://127.0.0.1:${PORT}/auth/login`);
  });
}

// Export the app for Vercel
export default app;
</file>

<file path="src/api/index.js">
import app from '../server/index.js';


export default app;
</file>

<file path="src/api/spotify.js">
// const BACKEND_URL = 'http://127.0.0.1:5000';
const BACKEND_URL = import.meta.env.PROD 
  ? 'https://a-spotify-clone-w49o.vercel.app'  
  : 'http://127.0.0.1:5000';

function getAccessToken() {
  return localStorage.getItem('spotify_access_token');
}

async function handleApiCall(apiFunction) {
  try {
    return await apiFunction();
  } catch (error) {
    if (error.message.includes('401') || error.message.includes('Not authenticated')) {
      localStorage.removeItem('spotify_access_token');
      localStorage.removeItem('spotify_refresh_token');
      window.location.href = 'http://127.0.0.1:5000/auth/login';
      throw new Error('Session expired. Please log in again.');
    }
    throw error;
  }
}

export async function getPlaylistTracks(playlistId) {
  return handleApiCall(async () => {

    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(`${BACKEND_URL}/api/playlists/${playlistId}/tracks`, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('401: Not authenticated');
      }
      throw new Error('Failed to fetch playlist tracks');
    }

    return await response.json();
  });
}

export async function playTrack(trackId) {
  return handleApiCall(async () => {
    const token = getAccessToken();

    if (!token) throw new Error('No access token');

    const response = await fetch(`${BACKEND_URL}/api/player/play`, {
      method: "PUT",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ trackId }),
    });

    if (!response.ok) {
      const errData = await response.json().catch(() => ({}));
      throw new Error(
        `Failed to play track: ${response.status} - ${errData.error || 'Unknown error'}`
      );
    }
  });
}

export async function togglePlayback() {
  return handleApiCall(async () => {
    const token = getAccessToken();

    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(`${BACKEND_URL}/api/player/toggle`, {
      method: 'PUT',
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        `Failed to toggle playback: ${response.status} - ${
          errorData.error || errorData.details || 'Unknown error'
        }`
      );
    }

    return true;
  });
}

export async function getPlayerState() {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(`${BACKEND_URL}/api/player`, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('401: Not authenticated');
      }
      throw new Error('Failed to fetch player state');
    }

    return await response.json();
  });
}

export async function skipToNext() {
  return handleApiCall(async () => {
    const token = getAccessToken();

    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(`${BACKEND_URL}/api/player/next`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        `Failed to skip to next: ${response.status} - ${
          errorData.error || errorData.details || 'Unknown error'
        }`
      );
    }

    return true;
  });
}

export async function skipToPrevious() {
  return handleApiCall(async () => {
    const token = getAccessToken();

    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(`${BACKEND_URL}/api/player/previous`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        `Failed to skip to previous: ${response.status} - ${
          errorData.error || errorData.details || 'Unknown error'
        }`
      );
    }

    return true;
  });
}

export async function setVolume(volume) {
  return handleApiCall(async () => {
    const token = localStorage.getItem('spotify_access_token');

    if (!token) throw new Error('No access token');

    const response = await fetch('http://127.0.0.1:5000/api/player/volume', {
      method: 'PUT',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ volume }),
    });

    if (!response.ok) {
      throw new Error('Failed to set volume');
    }
  });
}

export async function likeTrack(trackId) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    if (!token) throw new Error('No access token');

    const response = await fetch(`${BACKEND_URL}/api/tracks/${trackId}/like`, {
      method: 'PUT',
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error || 'Failed to like track');
    }

    return true;
  });
}

export async function unlikeTrack(trackId) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    if (!token) throw new Error('No access token');

    const response = await fetch(`${BACKEND_URL}/api/tracks/${trackId}/like`, {
      method: 'DELETE',
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error || 'Failed to unlike track');
    }

    return true;
  });
}

export async function checkTracksLiked(trackIds) {
  return handleApiCall(async () => {
    const ids = Array.isArray(trackIds) ? trackIds.join(',') : trackIds;

    const token = getAccessToken();
    if (!token) throw new Error('No access token');

    const response = await fetch(`${BACKEND_URL}/api/tracks/liked?ids=${ids}`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error || 'Failed to check liked tracks');
    }

    return await response.json();
  });
}

export async function seekToPosition(positionMs) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    if (!token) throw new Error('No access token');

    const response = await fetch(`${BACKEND_URL}/api/player/seek`, {
      method: 'PUT',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ position_ms: Math.floor(positionMs) }),
    });

    if (!response.ok) {
      const errData = await response.json().catch(() => ({}));
      throw new Error(`Seek failed: ${response.status} - ${errData.error || 'Unknown'}`);
    }

    return true;
  });
}

export async function getTopArtists(timeRange = 'medium_term', limit = 20) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/me/top/artists?time_range=${timeRange}&limit=${limit}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch top artists');
    }

    return await response.json();
  });
}

export async function getTopTracks(timeRange = 'medium_term', limit = 20) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/me/top/tracks?time_range=${timeRange}&limit=${limit}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch top tracks');
    }

    return await response.json();
  });
}

export async function getFollowedArtists(limit = 20) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/me/following?limit=${limit}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch followed artists');
    }

    return await response.json();
  });
}

export async function getRecentlyPlayed(limit = 20) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/me/player/recently-played?limit=${limit}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch recently played');
    }

    return await response.json();
  });
}

export async function getNewReleases(limit = 20) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/browse/new-releases?limit=${limit}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch new releases');
    }

    return await response.json();
  });
}

export async function search(query, type = 'track,artist,album,playlist', limit = 20, signal = null) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    if (!query || query.trim() === '') {
      throw new Error('Search query is required');
    }

    const fetchOptions = {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    };

    if (signal) {
      fetchOptions.signal = signal;
    }

    const response = await fetch(
      `${BACKEND_URL}/api/search?q=${encodeURIComponent(query)}&type=${type}&limit=${limit}`,
      fetchOptions
    );

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('401: Not authenticated');
      }
      throw new Error('Search failed');
    }

    return await response.json();
  });
}

export async function getArtist(artistId) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/artists/${artistId}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch artist');
    }

    return await response.json();
  });
}

export async function getArtistTopTracks(artistId) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/artists/${artistId}/top-tracks`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch artist top tracks');
    }

    return await response.json();
  });
}

export async function getAlbum(albumId) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/albums/${albumId}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch album');
    }

    return await response.json();
  });
}

export async function getUserPlaylists() {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(`${BACKEND_URL}/api/playlists`, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch playlists');
    }

    return await response.json();
  });
}

export async function getSavedAlbums(limit = 50, offset = 0) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/library/albums?limit=${limit}&offset=${offset}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch saved albums');
    }

    const data = await response.json();
    return data.items;
  });
}

export async function getLibraryFollowedArtists(limit = 50, after = null) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    let url = `${BACKEND_URL}/api/library/artists?limit=${limit}`;
    if (after) url += `&after=${after}`;

    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch followed artists');
    }

    const data = await response.json();
    return data.artists;
  });
}

export async function getSavedPodcasts(limit = 50, offset = 0) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/library/podcasts?limit=${limit}&offset=${offset}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch saved podcasts');
    }

    const data = await response.json();
    return data.items;
  });
}

export async function getLikedSongs(limit = 50, offset = 0) {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(
      `${BACKEND_URL}/api/library/liked-songs?limit=${limit}&offset=${offset}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch liked songs');
    }

    const data = await response.json();
    return data.items;
  });
}

export async function getLibraryContent() {
  return handleApiCall(async () => {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('No access token');
    }

    const response = await fetch(`${BACKEND_URL}/api/library`, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch library content');
    }

    return await response.json();
  });
}
</file>

<file path="src/App.css">
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.app-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background-color: #000;
}

.main-layout {
  flex: 1;
  display: flex;
  overflow: hidden;
}
.loading-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: black;
  color: white;
}
</file>

<file path="src/App.jsx">
import React, { useState, useEffect } from 'react';
import LoginPage from './components/loginpage/LoginPage';
import Sidebar from './components/sidebar/Sidebar';
import MainContent from './components/maincontent/MainContent';
import Player from './components/player/Player';
import './App.css';

const BACKEND_URL = 'http://127.0.0.1:5000';

function getTokensFromUrl() {
  const hash = window.location.hash.substring(1);
  const params = new URLSearchParams(hash);
  
  return {
    access_token: params.get('access_token'),
    refresh_token: params.get('refresh_token'),
    expires_in: params.get('expires_in'),
  };
}

export default function App() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [user, setUser] = useState(null);
  const [playlists, setPlaylists] = useState([]);
  const [loading, setLoading] = useState(true);
  const [currentView, setCurrentView] = useState('home');
  const [selectedPlaylist, setSelectedPlaylist] = useState(null);

  const [accessToken, setAccessToken] = useState(() => {
    return localStorage.getItem('spotify_access_token');
  });

const handlePlaylistSelect = (tracksData, playlistName, playlistId, playlistImage, playlistType, playlistTotal, playlistDisplayName) => {
    setSelectedPlaylist({
      id: playlistId,
      name: playlistName,
      tracks: tracksData,
      img: playlistImage,
      type: playlistType,
      total: playlistTotal,
      displayName: playlistDisplayName,
    });

  };

  useEffect(() => {
    const checkLoginStatus = async () => {
      const tokensFromUrl = getTokensFromUrl();
      
      if (tokensFromUrl.access_token) {
        localStorage.setItem('spotify_access_token', tokensFromUrl.access_token);
        localStorage.setItem('spotify_refresh_token', tokensFromUrl.refresh_token);
        setAccessToken(tokensFromUrl.access_token);
        
        window.history.replaceState({}, document.title, '/');
      }

      const token = accessToken || tokensFromUrl.access_token;

      if (!token) {
        setIsLoggedIn(false);
        setLoading(false);
        return;
      }

      try {
        const res = await fetch(`${BACKEND_URL}/api/me`, {
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        });

        if (res.ok) {
          const userData = await res.json();
          setUser(userData);
          setIsLoggedIn(true);

          const playlistsRes = await fetch(`${BACKEND_URL}/api/playlists`, {
            headers: {
              'Authorization': `Bearer ${token}`,
            },
          });

          if (playlistsRes.ok) {
            const playlistsData = await playlistsRes.json();
            setPlaylists(playlistsData);
          }
        } else {
          setIsLoggedIn(false);
          localStorage.removeItem('spotify_access_token');
          localStorage.removeItem('spotify_refresh_token');
        }
      } catch (err) {
        console.error('Auth check failed:', err);
        setIsLoggedIn(false);
      } finally {
        setLoading(false);
      }
    };

    checkLoginStatus();
  }, [accessToken]);

  const handleTrackPlay = async (trackId) => {
    try {
      const { playTrack } = await import('./api/spotify');
      await playTrack(trackId);
    } catch (err) {
      console.error('Failed to play track from App:', err);
    }
  };
  const handleLogout = () => {
    localStorage.removeItem('spotify_access_token');
    localStorage.removeItem('spotify_refresh_token');
    setAccessToken(null);
    setIsLoggedIn(false);
    setUser(null);
    setPlaylists([]);
    setCurrentView('home');
    setSelectedPlaylist(null);
  };

  if (loading) {
    return (
      <div className="loading-screen">
        <p>Loading your Spotify...</p>
      </div>
    );
  }

  if (!isLoggedIn) {
    return <LoginPage />;
  }

  return (
    <div className="app-container">
      <div className="main-layout">

        <Sidebar
          playlists={playlists}
          user={user}
          setCurrentView={setCurrentView}
          onLogout={handleLogout}
          onPlaylistSelect={handlePlaylistSelect}
        />
        {/* <div className="small-Size">
          <Player />
        </div> */}
        <MainContent 
        currentView={currentView}
        selectedPlaylist={selectedPlaylist}
        onPlaylistSelect={handlePlaylistSelect}   // Allow MainContent (Home) to trigger playlist view
        onTrackPlay={handleTrackPlay}              // Allow direct play from Home
        setCurrentView={setCurrentView}
        />
      </div>
      {/* <div  className="big-Size"> */}
        <Player />
      {/* </div> */}
    </div>
  );
}
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/loginpage/LoginPage.css">
.login-container {
  min-height: 100vh;
  background: linear-gradient(to bottom, #1a1a2e, #000);
  display: flex;
  align-items: center;
  justify-content: center;
}

.login-content {
  text-align: center;
}

.login-icon {
  width: 64px;
  height: 64px;
  color: #1db954;
  margin: 0 auto 16px;
}

.login-title {
  font-size: 60px;
  font-weight: bold;
  color: white;
  margin-bottom: 8px;
}

.login-subtitle {
  color: #b3b3b3;
  margin-bottom: 32px;
  font-size: 18px;
}

.login-button {
  background-color: #1db954;
  color: white;
  font-weight: 600;
  padding: 12px 32px;
  border-radius: 500px;
  border: none;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s;
}

.login-button:hover {
  background-color: #1ed760;
  transform: scale(1.05);
}
</file>

<file path="src/components/loginpage/LoginPage.jsx">
import React from 'react';
import { Music } from 'lucide-react';
import './LoginPage.css';

export default function LoginPage() {

const handleLogin = () => {
    window.location.href = 'http://127.0.0.1:5000/auth/login';
  };
  return (
    <div className="login-container">
      <div className="login-content">
        <Music className="login-icon" />
        <h1 className="login-title">Spotify</h1>
        <p className="login-subtitle">Music for everyone</p>
        <button onClick={handleLogin} className="login-button" >
          Log in with Spotify
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/maincontent/CurrentTrack.css">
.current-track-container {
  background: #181818;
  color: #ffffff;
  padding: 16px;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}

.status {
  text-align: center;
  color: #b3b3b3;
  margin-top: 40px;
}

/* =========================
   CURRENTLY PLAYING
   ========================= */
.now-playing {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.album-large {
  width: 260px;
  height: 260px;
  border-radius: 8px;
  object-fit: cover;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
  margin-bottom: 20px;
}

.track-details {
  width: 100%;
}

.track-title {
  font-size: 22px;
  font-weight: 700;
  margin-bottom: 6px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.track-artist {
  font-size: 16px;
  color: #b3b3b3;
}

.track-duration {
  display: block;
  margin-top: 6px;
  font-size: 14px;
  color: #b3b3b3;
}

/* =========================
   RECENTLY PLAYED (FALLBACK)
   ========================= */
.recent-track {
  margin-top: 24px;
}

.recent-label {
  display: block;
  font-size: 13px;
  color: #b3b3b3;
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.recent-content {
  display: flex;
  align-items: center;
  gap: 12px;
}

.album-small {
  width: 48px;
  height: 48px;
  border-radius: 4px;
  object-fit: cover;
}
</file>

<file path="src/components/maincontent/CurrentTrack.jsx">
import React, { useEffect, useState, useCallback } from "react";
import "./CurrentTrack.css";
import { getPlayerState, getRecentlyPlayed } from "../../api/spotify";

export default function CurrentTrack() {
  const [currentTrack, setCurrentTrack] = useState(null);
  const [recentTrack, setRecentTrack] = useState(null);
  const [loading, setLoading] = useState(true);

    const formatDuration = useCallback((ms) => {
    const min = Math.floor(ms / 60000);
    const sec = Math.floor((ms % 60000) / 1000);
    return `${min}:${sec.toString().padStart(2, "0")}`;
    }, []);

    const normalizeTrack = useCallback((track) => ({
    id: track.id,
    title: track.name,
    artist: track.artists.map((a) => a.name).join(", "),
    albumArt: track.album.images?.[0]?.url,
    duration: formatDuration(track.duration_ms),
    }), [formatDuration]);

    const fetchData = useCallback(async () => {
    try {
        setLoading(true);

        const player = await getPlayerState();

        if (player?.item) {
        setCurrentTrack(normalizeTrack(player.item));
        setRecentTrack(null);
        return;
        }

        const recent = await getRecentlyPlayed(1);
        if (recent?.items?.length) {
        setRecentTrack(normalizeTrack(recent.items[0].track));
        }

        setCurrentTrack(null);
    } catch (err) {
        console.error(err);
    } finally {
        setLoading(false);
    }
    }, [normalizeTrack]);


  useEffect(() => {
    fetchData();
    const interval = setInterval(fetchData, 10000);
    return () => clearInterval(interval);
  }, [fetchData]);

  if (loading) {
    return (
      <div className="current-track-container">
        <p className="status">Loading...</p>
      </div>
    );
  }

  return (
    <div className="current-track-container">
      {currentTrack ? (
        <div className="now-playing">
          <img
            src={currentTrack.albumArt}
            alt={currentTrack.title}
            className="album-large"
          />
          <div className="track-details">
            <h2 className="track-title">{currentTrack.title}</h2>
            <p className="track-artist">{currentTrack.artist}</p>
            <span className="track-duration">{currentTrack.duration}</span>
          </div>
        </div>
      ) : recentTrack ? (
        <div className="recent-track">
          <span className="recent-label">Recently played</span>
          <div className="recent-content">
            <img
              src={recentTrack.albumArt}
              alt={recentTrack.title}
              className="album-small"
            />
            <div>
              <p className="track-title">{recentTrack.title}</p>
              <p className="track-artist">{recentTrack.artist}</p>
            </div>
          </div>
        </div>
      ) : (
        <p className="status">No playback activity</p>
      )}
    </div>
  );
}
</file>

<file path="src/components/maincontent/HomePage.css">
.home-page {
  flex: 1;
  padding: 24px 32px;
  background: linear-gradient(to bottom, #1f1f1f 0%, #121212 20%, #121212 100%);
  overflow-y: auto;
  color: white;
  min-height: 100vh;
  scroll-behavior: smooth;
}

.home-header {
  margin-bottom: 24px;
}

.home-greeting {
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 4px;
  color: #ffffff;
}

.home-subtitle {
  font-size: 0.95rem;
  color: #b3b3b3;
  font-weight: 400;
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 60vh;
  color: #a7a7a7;
}

.loading-icon {
  width: 64px;
  height: 64px;
  margin-bottom: 24px;
  animation: gentlePulse 2s ease-in-out infinite;
}

@keyframes gentlePulse {
  0%, 100% { opacity: 0.6; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

/* Sections */
.home-section {
  margin-bottom: 40px;
}

.section-header {
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.section-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: white;
  display: flex;
  align-items: center;
  gap: 12px;
  margin: 0;
}

.section-icon {
  width: 24px;
  height: 24px;
  color: #ffffff;
}

.section-description {
  font-size: 0.875rem;
  color: #b3b3b3;
  font-weight: 400;
  margin-top: 4px;
}

/* Quick Picks Grid - Smaller horizontal cards */
.quick-picks {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 12px;
  margin-bottom: 8px;
}

.quick-pick-item {
  background: #181818;
  border-radius: 6px;
  display: flex;
  align-items: center;
  cursor: pointer;
  transition: background-color 0.3s ease;
  overflow: hidden;
  height: 64px;
  position: relative;
}

.quick-pick-item:hover {
  background: #282828;
}

.quick-pick-image {
  width: 64px;
  height: 64px;
  flex-shrink: 0;
  position: relative;
  overflow: hidden;
  background: #282828;
}

.quick-pick-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.quick-pick-title {
  flex: 1;
  padding: 0 16px;
  font-weight: 600;
  font-size: 0.95rem;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.quick-pick-subtitle {
  position: absolute;
  bottom: 12px;
  left: 96px;
  font-size: 0.8rem;
  color: #b3b3b3;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: calc(100% - 180px);
}

.quick-pick-playy {
  width: 40px;
  height: 40px;
  background: hsl(141, 73%, 42%);
  border: none;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  margin-right: 12px;
  opacity: 0;
  transform: translateY(8px);
  transition: all 0.3s ease;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
  flex-shrink: 0;
}

.quick-pick-item:hover .quick-pick-playy {
  opacity: 1;
  transform: translateY(0);
}

.quick-pick-playy:hover {
  transform: scale(1.05);
  background: #1ed760;
}

.play-iicon {
  width: 18px;
  height: 18px;
  color: black;
  /* margin-left: 2px; */
}

/* Artists Grid - No background until hover */
.artists-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 24px;
}

.artist-card {
  background: transparent;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.artist-card:hover {
  background: #181818;
}

.artist-image-wrapper {
  position: relative;
  margin-bottom: 16px;
  aspect-ratio: 1;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
}

.artist-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.artist-placeholder {
  width: 100%;
  height: 100%;
  background: #282828;
  display: flex;
  align-items: center;
  justify-content: center;
}

.placeholder-icon {
  width: 48px;
  height: 48px;
  color: #727272;
}

/* No play button for artists */
.artist-play-btn {
  display: none;
}

.artist-name {
  font-size: 1rem;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.artist-type {
  font-size: 0.875rem;
  color: #b3b3b3;
  margin: 0;
  text-transform: capitalize;
  font-weight: 400;
}

/* Tracks Grid - No background until hover */
.tracks-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 24px;
}

.track-card {
  background: transparent;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.track-card:hover {
  background: #181818;
}

.track-image-wrapper {
  position: relative;
  margin-bottom: 16px;
  aspect-ratio: 1;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
}

.track-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.track-placeholder {
  width: 100%;
  height: 100%;
  background: #282828;
  display: flex;
  align-items: center;
  justify-content: center;
}

.track-play-bttn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #1db954;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: 0;
  transform: translateY(8px);
  transition: all 0.3s ease;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
}

.track-card:hover .track-play-bttn {
  opacity: 1;
  transform: translateY(0);
}

.track-play-bttn:hover {
  transform: scale(1.05);
  background: #1ed760;
}

.track-play-bttn .play-iicon {
  width: 16px;
  height: 16px;
  fill: black;
}

.track-name {
  font-size: 1rem;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.track-artist {
  font-size: 0.875rem;
  color: #b3b3b3;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-weight: 400;
}

/* Empty State */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  gap: 16px;
  text-align: center;
}

.empty-icon {
  width: 64px;
  height: 64px;
  color: #727272;
}

.empty-state h2 {
  font-size: 1.5rem;
  margin: 0;
  color: #fff;
  font-weight: 700;
}

.empty-state p {
  font-size: 1rem;
  color: #b3b3b3;
  margin: 0;
  max-width: 400px;
}

/* Responsive Design */
@media (max-width: 1400px) {
  .quick-picks {
    grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
  }
}

@media (max-width: 1000px) {
  .quick-picks {
    grid-template-columns: 1fr 1fr;
    gap: 20px;
  }
    .quick-pick-playy{
    display: none;
  }
  .artists-grid,
  .tracks-grid {
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
  }
  
  #quick-pick-image {
    width: 50px;
  }
}

@media (max-width: 768px) {
  .home-page {
    padding: 50px 24px;
  }

  .home-greeting {
    font-size: 1.75rem;
  }

  .section-title {
    font-size: 1.25rem;
  }

  .quick-picks {
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .quick-pick-item {
    height: 54px;
  }

  #quick-pick-image {
    width: 55px;
  }

  .quick-pick-title {
    font-size: 0.15rem;
  }
  .quick-pick-playy{
    display: none;
  }
  .artists-grid,
  .tracks-grid {
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 16px;
  }
}

@media (max-width: 480px) {
  .home-page {
    padding: 16px;
  }

  .home-greeting {
    font-size: 1.5rem;
  }

  .quick-picks {
    grid-template-columns: 1fr;
  }

  .artists-grid,
  .tracks-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
  }

  .artist-card,
  .track-card {
    padding: 12px;
  }
}
.home-page {
  overflow-y: auto;
  scroll-behavior: smooth;
}
.home-page::-webkit-scrollbar {
  width: 12px;
}

.home-page::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.03);
}

.home-page::-webkit-scrollbar-thumb{
  background: rgba(255, 255, 255, 0.2);
}

.home-page::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}
</file>

<file path="src/components/maincontent/HomePage.jsx">
import React, { useState, useEffect } from 'react';
import { Play, Music, TrendingUp, Clock, Sparkles } from 'lucide-react';
import { getTopTracks, getTopArtists, getRecentlyPlayed, playTrack } from '../../api/spotify';
import './HomePage.css';

export default function HomePage() {
  const [topTracks, setTopTracks] = useState([]);
  const [topArtists, setTopArtists] = useState([]);
  const [recentlyPlayed, setRecentlyPlayed] = useState([]);
  const [loading, setLoading] = useState(true);
  const [greeting, setGreeting] = useState('Good afternoon');

  useEffect(() => {
    const hour = new Date().getHours();
    if (hour < 12) setGreeting('Good Morning!');
    else if (hour < 18) setGreeting('Good Afternoon!');
    else setGreeting('Good Evening!');

    loadHomeData();
  }, []);

  const loadHomeData = async () => {
    try {
      setLoading(true);
      
      const [tracks, artists, recent] = await Promise.all([
        getTopTracks('short_term', 10),
        getTopArtists('short_term', 8),
        getRecentlyPlayed(8),
      ]);

      setTopTracks(tracks.items || []);
      setTopArtists(artists.items || []);
      setRecentlyPlayed(recent.items || []);
    } catch (error) {
      console.error('Failed to load home data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleTrackPlay = (trackId) => {
    playTrack(trackId);
  };

  if (loading) {
    return (
      <div className="home-page">
        <div className="loading-container">
          <Music className="loading-icon" />
          <p>Loading your music...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="home-page">
      <div className="home-header">
        <h1 className="home-greeting">{greeting}</h1>
      </div>
      
      {/* Quick Picks - Jump Back In */}
      {topTracks.length > 0 && (
        <section className="home-section">
          <div className="quick-picks">
            {topTracks.slice(0, 8).map((track) => (
              <div
                key={track.id}
                className="quick-pick-item"
                onClick={()=> handleTrackPlay(track.id)}
              >
                <div className="quick-pick-image"
                id='quick-pick-image'>
                  {track.album?.images?.[0] ? (
                    <img src={track.album.images[0].url} alt={track.name} />
                  ) : (
                    <div style={{
                      background: '#282828',
                      width: '100%',
                      height: '100%',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}>
                      <Music style={{ width: '40px', height: '40px', color: '#727272' }} />
                    </div>
                  )}
                </div>

                <div className="quick-pick-title">{track.name}</div>

                <button className="quick-pick-playy">
                  <Play className="play-iicon" fill="black" onClick={()=> handleTrackPlay(track.id)}/>
                </button>
              </div>
            ))}
          </div>
        </section>
      )}

      {/* Top Artists Section */}
      {topArtists.length > 0 && (
        <section className="home-section">
          <div className="section-header">
            <h2 className="section-title">
              Your top artists this month
            </h2>
          </div>
          <div className="artists-grid">
            {topArtists.map((artist) => (
              <div key={artist.id} className="artist-card">
                <div className="artist-image-wrapper">
                  {artist.images?.[0] ? (
                    <img 
                      src={artist.images[0].url} 
                      alt={artist.name}
                      className="artist-image"
                    />
                  ) : (
                    <div className="artist-placeholder">
                      <Music className="placeholder-icon" />
                    </div>
                  )}
                  <button className="artist-play-btn">
                    <Play className="play-icon" fill="black" />
                  </button>
                </div>
                <h3 className="artist-name">{artist.name}</h3>
                <p className="artist-type">Artist</p>
              </div>
            ))}
          </div>
        </section>
      )}

      {/* Recently Played Section */}
      {recentlyPlayed.length > 0 && (
        <section className="home-section">
          <div className="section-header">
            <h2 className="section-title">
              Recently played
            </h2>
          </div>
          <div className="tracks-grid">
            {recentlyPlayed.map((item, idx) => {
              const track = item.track;
              return (
                <div 
                  key={`${track.id}-${idx}`} 
                  className="track-card"
                  onClick={() => handleTrackPlay(track.id)}
                >
                  <div className="track-image-wrapper">
                    {track.album?.images?.[0] ? (
                      <img 
                        src={track.album.images[0].url} 
                        alt={track.name}
                        className="track-image"
                      />
                    ) : (
                      <div className="track-placeholder">
                        <Music className="placeholder-icon" />
                      </div>
                    )}
                    <button className="track-play-bttn">
                      <Play className="play-iicon" fill="black" />
                    </button>
                  </div>
                  <h3 className="track-name">{track.name}</h3>
                  <p className="track-artist">
                    {track.artists?.map(a => a.name).join(', ')}
                  </p>
                </div>
              );
            })}
          </div>
        </section>
      )}

      {/* More Top Tracks Section */}
      {topTracks.length > 8 && (
        <section className="home-section">
          <div className="section-header">
            <h2 className="section-title">
              Your top tracks
            </h2>
          </div>
          <div className="tracks-grid">
            {topTracks.slice(8).map((track) => (
              <div 
                key={track.id} 
                className="track-card"
                onClick={() => handleTrackPlay(track.id)}
              >
                <div className="track-image-wrapper">
                  {track.album?.images?.[0] ? (
                    <img 
                      src={track.album.images[0].url} 
                      alt={track.name}
                      className="track-image"
                    />
                  ) : (
                    <div className="track-placeholder">
                      <Music className="placeholder-icon" />
                    </div>
                  )}
                  <button className="track-play-bttn">
                    <Play className="play-iicon" />
                  </button>
                </div>
                <h3 className="track-name">{track.name}</h3>
                <p className="track-artist">
                  {track.artists?.map(a => a.name).join(', ')}
                </p>
              </div>
            ))}
          </div>
        </section>
      )}

      {/* Empty State */}
      {topTracks.length === 0 && topArtists.length === 0 && recentlyPlayed.length === 0 && (
        <div className="empty-state">
          <Music className="empty-icon" />
          <h2>Start Listening</h2>
          <p>Play some music to see your personalized recommendations here</p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/maincontent/Library.css">
.library-view {
  padding: 24px;
  height: 100%;
  width: 100%;
  overflow-y: auto;
  scroll-behavior: smooth;
  background-color: #000;
  color: white;
}
.library-view::-webkit-scrollbar {
  width: 12px;
  color: rgba(255, 255, 255, 0.13);
}
.library-view::-webkit-scrollbar-track{
  background: rgba(255, 255, 255, 0.03);
}
.library-view::-webkit-scrollbar-thumb{
  background: rgba(255, 255, 255, 0.2);
}

.library-view::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}
.library-header {
  margin-bottom: 24px;
}

.library-header h1 {
  font-size: 32px;
  font-weight: 700;
}

.library-filters {
  display: flex;
  gap: 8px;
  margin-bottom: 32px;
  overflow-x: auto;
  padding-bottom: 8px;
  scrollbar-width: none; 
}

.library-filters::-webkit-scrollbar {
  display: none;
}

.filter-btn {
  padding: 8px 16px;
  background: #282828;
  border: none;
  border-radius: 500px;
  color: #b3b3b3;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.2s;
}

.filter-btn.active,
.filter-btn:hover {
  background: white;
  color: black;
}

.library-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 24px;
}

.library-item {
  background: none;
  border: none;
  text-align: left;
  cursor: pointer;
  transition: transform 0.2s ease;
  border-radius: 8px;
  padding: 8px;
}

.library-item:hover {
  transform: scale(1.06);
  background: rgba(255, 255, 255, 0.1);
}

.library-item-image {
  width: 100%;
  aspect-ratio: 1 / 1;
  border-radius: 8px;
  overflow: hidden;
  background: #282828;
  margin-bottom: 12px;
  position: relative;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.library-item-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.library-item-image .placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 48px;
  color: #535353;
  background: linear-gradient(135deg, #282828, #1a1a1a);
}

.library-item-info .name {
  display: block;
  font-weight: 600;
  font-size: 16px;
  margin-bottom: 4px;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.library-item-info .subtitle {
  font-size: 14px;
  color: #b3b3b3;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.library-view p {
  text-align: center;
  color: #b3b3b3;
  font-size: 18px;
  margin-top: 80px;
}

.library-item:has(img[src*="liked-songs"]) .library-item-image,
.library-item:has(.placeholder) .library-item-image {
  background: linear-gradient(135deg, #450af5, #8e8ee5);
}
@media (max-width: 768px) {
  .library-view{
    padding: 50px 24px;
  }
}
</file>

<file path="src/components/maincontent/Library.jsx">
import React, { useState, useEffect } from 'react';
import { Music } from 'lucide-react';
import './Library.css';
import { getLibraryContent, getPlaylistTracks } from '../../api/spotify'; 

export default function Library({ setCurrentView, onPlaylistSelect }) {
  const [activeFilter, setActiveFilter] = useState('playlists');
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);

  const filters = ['playlists', 'artists', 'albums', 'podcasts'];

  useEffect(() => {
    const loadLibrary = async () => {
      setLoading(true);
      try {
        const data = await getLibraryContent(); 

        let displayItems = [];

        if (activeFilter === 'playlists') {
          displayItems = [
            data.likedSongs, 
            ...data.playlists
          ];
        } else if (activeFilter === 'artists') {
          displayItems = data.artists;
        } else if (activeFilter === 'albums') {
          displayItems = data.albums;
        } else if (activeFilter === 'podcasts') {
          displayItems = data.podcasts;
        }

        setItems(displayItems);
      } catch (err) {
        console.error('Failed to load library:', err);
      } finally {
        setLoading(false);
      }
    };

    loadLibrary();
  }, [activeFilter]);

  const handleItemClick = async (item) => {
    if (item.type === 'playlist' && item.id === 'liked-songs') {
        setCurrentView('liked');
        onPlaylistSelect(item); 
    }else if (item.type === "playlist" && item.id != "liked-songs"){
        try {
        const tracksData = await getPlaylistTracks(item.id);
        onPlaylistSelect(tracksData, item.name, item.id, item.images, item.type, item.tracks.total, item.display_name);
        setCurrentView("playlist");
        } catch (error) {
        console.error('Error fetching tracks:', error);
        }
    }else if (item.type === 'artist') {
      setCurrentView('artist');
    } else if (item.type === 'album') {
      setCurrentView('album');
    }
  };

  return (
    <div className="library-view">
      <div className="library-header">
        <h1>Your Library</h1>
      </div>

      <div className="library-filters">
        {filters.map(filter => (
          <button
            key={filter}
            className={`filter-btn ${activeFilter === filter ? 'active' : ''}`}
            onClick={() => setActiveFilter(filter)}
          >
            {filter.charAt(0).toUpperCase() + filter.slice(1)}
          </button>
        ))}
      </div>

      {loading ? (
        <div className="home-page">
        <div className="loading-container">
          <Music className="loading-icon" />
          <p>Loading your music...</p>
        </div>
      </div>
      ) : (
        <div className="library-grid">
          {items.map(item => (
            <button
              key={item.id}
              className="library-item"
              onClick={() => handleItemClick(item)}
            >
              <div className="library-item-image">
                {item.images?.[0]?.url ? (
                  <img src={item.images[0].url} alt={item.name} />
                ) : (
                  <div className="placeholder">â™ª</div>
                )}
              </div>
              <div className="library-item-info">
                <span className="name">{item.name}</span>
                <span className="subtitle">
                  {item.type === 'artist' ? 'Artist' :
                   item.type === 'album' ? `Album â€¢ ${item.artists?.[0]?.name}` :
                   item.type === 'show' ? 'Podcast' :
                   `Playlist â€¢ ${item.owner?.display_name || 'You'}`}
                </span>
              </div>
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/maincontent/MainContent.css">
.main-content {
  flex: 1;
  padding: 32px;
}

.home-view {
  background: linear-gradient(to bottom, #3b4371, #000);
}
.most-content-wrapper{
  width: 100%;
}
.current-content-wrapper{
  width: 30%;
}
.search-view {
  background: linear-gradient(to bottom, #4a5568, #000);
}

.main-title {
  font-size: 36px;
  font-weight: bold;
  color: white;
  margin-bottom: 32px;
}

.section-title {
  font-size: 24px;
  font-weight: bold;
  color: white;
  margin-top: 48px;
  margin-bottom: 16px;
}

/* Quick Picks */
.quick-picks {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
  margin-bottom: 32px;
}

@media (min-width: 768px) {
  .quick-picks {
    grid-template-columns: repeat(3, 1fr);
  }
}

.quick-pick-item {
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  display: flex;
  align-items: center;
  cursor: pointer;
  transition: background-color 0.2s;
  position: relative;
  overflow: hidden;
}

.quick-pick-item:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

.quick-pick-image {
  width: 80px;
  height: 80px;
  background: linear-gradient(135deg, #a855f7, #3b82f6);
  border-radius: 4px 0 0 4px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.quick-pick-icon {
  width: 32px;
  height: 32px;
  color: white;
}

.quick-pick-title {
  color: white;
  font-weight: 600;
  padding: 0 16px;
  flex: 1;
  font-size: 14px;
}

.quick-pick-play {
  width: 48px;
  height: 48px;
  color: #1db954;
  margin-right: 16px;
  opacity: 0;
  transition: opacity 0.2s;
}

.quick-pick-item:hover .quick-pick-play {
  opacity: 1;
}

/* Search View */
.search-input {
  width: 100%;
  max-width: 672px;
  background-color: white;
  border-radius: 500px;
  padding: 12px 24px;
  color: black;
  font-weight: 500;
  border: none;
  font-size: 14px;
}

.genre-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

@media (min-width: 768px) {
  .genre-grid {
    grid-template-columns: repeat(4, 1fr);
  }
}

.genre-card {
  background: linear-gradient(135deg, #a855f7, #ec4899);
  border-radius: 8px;
  padding: 16px;
  height: 128px;
  position: relative;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.2s;
}

.genre-card:hover {
  transform: scale(1.05);
}

.genre-card h3 {
  color: white;
  font-weight: bold;
  font-size: 20px;
}
.loading{
  color: white;
}
.songs-container {
  background-color: rgba(0, 0, 0, 0.4);
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(4px);
}

/* Header - Grid structure that song-row will match */
.songs-header {
  display: grid;
  grid-template-columns: 48px 1fr 180px 100px;
  gap: 16px;
  color: #b3b3b3;
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.4px;
  padding: 0 12px 12px;
  margin-bottom: 8px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.header-duration {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  gap: 8px;
}

/* Playlist tracks container */
.playlist-tracks {
  height: 265px;
  overflow-y: scroll;
  scroll-behavior: smooth;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.playlist-tracks::-webkit-scrollbar {
  display: none;
}

/* Song row - MUST match songs-headerr grid */
.song-row {
  display: grid;
  grid-template-columns: 50px 1fr 1fr 80px;
  gap: 16px;
  align-items: center;
  padding: 10px 16px;
  border-radius: 8px;
  transition: all 0.2s ease;
  cursor: pointer;
  color: #ddd;
}

.song-row:hover {
  background-color: rgba(255, 255, 255, 0.08);
  transform: translateX(4px);
}

/* Column 1: Number + Play icon */
.song-number {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  padding-left: 10px;
}

.number-text {
  font-weight: 500;
  color: #b3b3b3;
  font-size: 14px;
}

.play-icon {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
  color: white;
}

.song-row:hover .number-text {
  opacity: 0;
}

.song-row:hover .play-icon {
  opacity: 1;
  transform: translateX(-50%) scale(1.1);
}

/* Column 2: Song info (thumbnail + title/artist) */
.song-info {
  display: flex;
  align-items: center;
  gap: 12px;
  min-width: 0;
}

.song-thumbnail {
  width: 48px;
  height: 48px;
  flex-shrink: 0;
}

.song-thumbnail img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  transition: transform 0.3s ease;
}

.song-row:hover .song-thumbnail img {
  transform: scale(1.08);
}

.song-details {
  display: flex;
  flex-direction: column;
  gap: 3px;
  overflow: hidden;
  min-width: 0;
}

.song-title {
  color: white;
  font-weight: 600;
  font-size: 14.5px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.song-artist {
  color: #b3b3b3;
  font-size: 13px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Column 3: Album */
.song-album {
  color: #b3b3b3;
  font-size: 13.5px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding-right: 8px;
}

/* Column 4: Duration */
.song-duration {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 10px;
  color: #b3b3b3;
  font-size: 13.5px;
}

.duration-text {
  min-width: 40px;
  text-align: right;
}

.heart-icon {
  flex-shrink: 0;
  color: #b3b3b3;
  transition: all 0.2s ease;
  opacity: 0;
}

.heart-icon:hover {
  stroke: #1db954;
  transform: scale(1.2);
  color: #1db954;
  fill: #1db954;
}

.heart-icon.liked {
  animation: heartbeat 0.6s ease;
  color: #1db954;
  fill: #1db954;
}

.song-row:hover .heart-icon {
  opacity: 1;
}

/* Playlist page styling */
.playlist-pagee {
  width: 100%;
  padding: 20px 35px 0px;
  margin-bottom: 10px;
  color: #fff;
}

.playlist-headerr {
  display: flex;
  align-items: flex-end;
  gap: 24px;
  margin-bottom: 23px;
  padding-bottom: 16px;
}

.playlist-image-containerr {
  flex-shrink: 0;
  width: 232px;
  height: 232px;
  box-shadow: 0 4px 60px rgba(0, 0, 0, 0.5);
  border-radius: 8px;
  overflow: hidden;
  background: #282828;
}

/* Collage Container */
.playlist-header-collage {
  width: 232px;
  height: 232px;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
  flex-shrink: 0;
  background: #282828;
}

.collage-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  width: 100%;
  height: 100%;
  gap: 0;
}

.collage-tile {
  position: relative;
  overflow: hidden;
}

.collage-tile img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  transition: transform 0.3s ease; 
}

.playlist-image-placeholder {
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #333, #111);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #666;
  font-size: 2.5rem;
  font-weight: bold;
}

.playlist-infoo {
  flex: 1;
  min-width: 0;
}

.playlist-typee {
  font-size: 0.875rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  color: #b3b3b3;
  text-transform: uppercase;
}

.playlist-titlee {
  font-size: 3.5rem;
  font-weight: 900;
  margin: 8px 0 16px;
  line-height: 1;
}

.playlist-descriptionn {
  font-size: 1rem;
  color: #b3b3b3;
  margin-bottom: 16px;
  line-height: 1.4;
}

.playlist-metaa {
  font-size: 0.875rem;
  color: #b3b3b3;
}

.playlist-meta-separatorr {
  margin: 0 8px;
}

.playlist-ownerr {
  font-weight: 600;
  color: white;
}

.playlist-tracks-sectionn {
  margin-top: -10px;
  margin-bottom: 52px;
}

/* Songs header - defines the column structure */
.songs-headerr {
  display: grid;
  grid-template-columns: 50px 1fr 1fr 80px;
  gap: 16px;
  padding: 16px;
  color: #b3b3b3;
  font-size: 0.875rem;
  font-weight: 500;
  border-bottom: 1px solid #282828;
  margin-bottom: 8px;
  background: #121212;
  position: sticky;
  top: 0;
  z-index: 10;
}

.header-numberr {
  padding-left: 10px;
  text-align: center;
}

.header-titlee {
  padding-left: 0;
}

.header-albumm {
  padding-left: 0;
}

.header-durationn {
  text-align: right;
  display: flex;
  align-items: center;
  justify-content: flex-end;
}

/* Tablet responsiveness */
@media (max-width: 1024px) {
  .songs-headerr {
    grid-template-columns: 50px 1fr 150px 80px;
  }

  .song-row {
    grid-template-columns: 50px 1fr 150px 80px;
  }
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .playlist-headerr {
    flex-direction: column;
    align-items: center;
    text-align: center;
  }

  .playlist-titlee {
    font-size: 2.5rem;
  }

  .playlist-image-containerr {
    width: 180px;
    height: 180px;
  }

  .songs-headerr {
    grid-template-columns: 40px 1fr 70px;
    gap: 12px;
    padding: 12px;
  }

  .song-row {
    grid-template-columns: 40px 1fr 70px;
    gap: 12px;
    padding: 8px 12px;
  }

  .song-album,
  .header-albumm {
    display: none;
  }

  .song-thumbnail {
    width: 44px;
    height: 44px;
  }
}

/* Small mobile responsiveness */
@media (max-width: 480px) {
  .songs-headerr {
    grid-template-columns: 35px 1fr 65px;
    gap: 8px;
    padding: 10px 8px;
  }

  .song-row {
    grid-template-columns: 35px 1fr 65px;
    gap: 8px;
    padding: 6px 8px;
  }

  .song-number {
    padding-left: 0;
  }

  .header-numberr {
    padding-left: 0;
  }

  .song-duration {
    font-size: 12.5px;
    gap: 6px;
  }

  .song-title {
    font-size: 13px;
  }

  .song-artist {
    font-size: 12px;
  }

  .song-thumbnail {
    width: 40px;
    height: 40px;
  }
}
</file>

<file path="src/components/maincontent/MainContent.jsx">
import React from 'react';
import HomePage from './HomePage'; 
import PlaylistView from '../userdetails/PlayListView';
import { Clock } from 'lucide-react';
import './MainContent.css';
import Search from './Search';
import Library from './Library';
import LikedSongs from '../userdetails/LikedSongs';
import CurrentTrack from './CurrentTrack';


export default function MainContent({ currentView, selectedPlaylist, setCurrentView, onPlaylistSelect}){
    // const [currentView, setCurrentView] = useState(null);

  if (currentView === 'home') {
    return (
      <HomePage />
    );
  }

  if (currentView === 'search') {
    return (
      <>
        <Search />      
      </>

    )
  }
  if (currentView === "library"){
    return(
      // <div className='most-content-wrapper'>
      //   <div className='lib-content-wrapper'>
        <Library setCurrentView={setCurrentView} 
          onPlaylistSelect={onPlaylistSelect}
        />
        // {/* </div> */}
        // {/* <div className='current-content-wrapper'> 
        // <CurrentTrack 
        // currentTrack={true}
        // recentlyPlayed={selectedPlaylist}
        // />
        // </div> */}
      // </div>
    )
  }
  if (currentView === "liked"){
    return(
      <>
        <LikedSongs />
      </>
    )
  }
  if (currentView === 'playlist' && selectedPlaylist) {
  const trackImages = (selectedPlaylist.tracks?.items || [])
    .map(item => item.track?.album?.images?.[0]?.url || item.track?.album?.images?.[1]?.url) // fallback to medium if no large
    .filter(Boolean);

  const fallbackImages = selectedPlaylist.images || selectedPlaylist.img || [];
  const fallbackUrls = Array.isArray(fallbackImages)
    ? fallbackImages.map(img => img?.url).filter(Boolean)
    : (fallbackImages?.url ? [fallbackImages.url] : []);

  const sourceUrls = trackImages.length > 0 ? trackImages : fallbackUrls;


  const uniqueUrls = [...new Set(sourceUrls)]; 
  const collageUrls = uniqueUrls.slice(0, 4);

  while (collageUrls.length < 4) {
    collageUrls.push(uniqueUrls[collageUrls.length % uniqueUrls.length] || null);
  }

  const playlistImage = (
    <div className="playlist-header-collage">
      <div className="collage-grid">
        {collageUrls.map((imageUrl, index) => (
          <div key={index} className="collage-tile">
            {imageUrl ? (
              <img
                src={imageUrl}
                alt={`Cover ${index + 1}`}
                onError={(e) => {
                  e.target.style.display = 'none';
                  e.target.nextSibling.style.display = 'flex';
                }}
              />
            ) : null}

            <div
              className="playlist-image-placeholder"
              style={{ display: imageUrl ? 'none' : 'flex' }}
            >
              <span>â™ª</span>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
    return (
      <div className="playlist-pagee">
        <div className="playlist-headerr">
          <div className="playlist-image-containerr">
            {playlistImage}
          </div>

          <div className="playlist-infoo">
            <span className="playlist-typee">PLAYLIST</span>
            <h1 className="playlist-titlee">{selectedPlaylist.name || selectedPlaylist.displayName}</h1>

            {selectedPlaylist.description && (
              <p className="playlist-descriptionn">
                {selectedPlaylist.description}
              </p>
            )}

            <div className="playlist-metaa">
              <span className="playlist-ownerr">
                {selectedPlaylist.displayName || selectedPlaylist.owner?.display_name || 'Spotify'}
              </span>
              <span className="playlist-meta-separatorr"> â€¢ </span>
              <span className="playlist-tracks-countt">
                {selectedPlaylist.total || selectedPlaylist.tracks?.total || 0} songs
              </span>
            </div>
          </div>
        </div>

        <div className="playlist-tracks-sectionn">
          <div className="songs-headerr">
            <div className="header-numberr">#</div>
            <div className="header-titlee">TITLE</div>
            <div className="header-albumm">ALBUM</div>
            <div className="header-durationn">
              <Clock className="clock-icon" />
            </div>
          </div>

          <PlaylistView playlist={selectedPlaylist} />
        </div>
      </div>
    );
  }

  return (
    <div className="main-content">
      <h1>Something went wrong. Go back to Home.</h1>
    </div>
  );
}
</file>

<file path="src/components/maincontent/Search.css">
.search-page {
  flex: 1;
  padding: 24px 32px;
  background: linear-gradient(to bottom, #1f1f1f 0%, #121212 20%, #121212 100%);
  overflow-y: auto;
  scroll-behavior: smooth;
  color: white;
  min-height: 100vh;
}
.search-page::-webkit-scrollbar {
  width: 12px;
}
.search-page::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.03);
}

.search-page::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
}

.search-page::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}
/* Search Header */
.search-header {
  margin-bottom: 24px;
}

.search-input-wrapper {
  position: relative;
  max-width: 400px;
}

.search-input {
  width: 100%;
  padding: 12px 16px 12px 48px;
  background: #242424;
  border: none;
  border-radius: 24px;
  color: white;
  font-size: 0.95rem;
  outline: none;
  transition: background-color 0.2s ease;
}

.search-input:focus {
  background: #2a2a2a;
}

.search-input::placeholder {
  color: #727272;
}

.search-input-icon {
  position: absolute;
  left: 16px;
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  color: #727272;
}

.search-clear-btn {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #b3b3b3;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px;
  border-radius: 50%;
  transition: background-color 0.2s ease;
}

.search-clear-btn:hover {
  background: rgba(255, 255, 255, 0.1);
}

.search-clear-btn svg {
  width: 20px;
  height: 20px;
}

/* Search Filters */
.search-filters {
  display: flex;
  gap: 8px;
  margin-bottom: 32px;
  flex-wrap: wrap;
}

.filter-btn {
  padding: 8px 16px;
  background: transparent;
  border: none;
  border-radius: 20px;
  color: white;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.filter-btn:hover {
  background: rgba(255, 255, 255, 0.1);
}

.filter-btn.active {
  background: white;
  color: black;
}

/* Loading State */
.search-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  gap: 16px;
}

.loading-icon {
  width: 48px;
  height: 48px;
  color: #1db954;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Search Results */
.search-results {
  padding-bottom: 40px;
}

.search-section {
  margin-bottom: 48px;
}

.search-section-title {
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: 16px;
  color: white;
}

/* Tracks List */
.tracks-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.track-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.track-item:hover {
  background: rgba(255, 255, 255, 0.1);
}

.track-item-left {
  display: flex;
  align-items: center;
  gap: 16px;
  flex: 1;
  min-width: 0;
}

.track-item-image {
  width: 48px;
  height: 48px;
  flex-shrink: 0;
  border-radius: 4px;
  overflow: hidden;
  background: #282828;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.track-item-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.track-item-icon {
  width: 24px;
  height: 24px;
  color: #727272;
}

.track-item-play-wrapper {
  position: absolute;
  width: 20px;
  height: 20px;
  background: none;
  border: none;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.track-item:hover .track-item-play-wrapper {
  opacity: 1;
}

.track-item-play-wrapper .search-play-icon {
  width: 5px;
  height: 5px;
  margin-left: 2px;
}

.track-item-info {
  flex: 1;
  min-width: 0;
}

.track-item-name {
  font-size: 1rem;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.track-item-artist {
  font-size: 0.875rem;
  color: #b3b3b3;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.track-item-album {
  font-size: 0.875rem;
  color: #b3b3b3;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 300px;
  text-align: right;
}

/* Artists Grid */
.artists-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 24px;
}

.artist-card {
  background: transparent;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.artist-card:hover {
  background: #181818;
}

.artist-image-wrapper {
  position: relative;
  margin-bottom: 16px;
  aspect-ratio: 1;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
}

.artist-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.artist-placeholder {
  width: 100%;
  height: 100%;
  background: #282828;
  display: flex;
  align-items: center;
  justify-content: center;
}

.placeholder-icon {
  width: 48px;
  height: 48px;
  color: #727272;
}

.artist-name {
  font-size: 1rem;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.artist-type {
  font-size: 0.875rem;
  color: #b3b3b3;
  margin: 0;
  text-transform: capitalize;
}

/* Albums Grid */
.albums-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 24px;
}

.album-card {
  background: transparent;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.album-card:hover {
  background: #181818;
}

.album-image-wrapper {
  position: relative;
  margin-bottom: 16px;
  aspect-ratio: 1;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
}

.album-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.album-placeholder {
  width: 100%;
  height: 100%;
  background: #282828;
  display: flex;
  align-items: center;
  justify-content: center;
}

.album-play-btn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #1db954;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: 0;
  transform: translateY(8px);
  transition: all 0.3s ease;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
}

.album-card:hover .album-play-btn {
  opacity: 1;
  transform: translateY(0);
}

.album-play-btn:hover {
  transform: scale(1.05);
  background: #1ed760;
}

.album-play-btn .album-play-icon {
  width: 14px;
  height: 14px;
}

.album-name {
  font-size: 1rem;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.album-artist {
  font-size: 0.875rem;
  color: #b3b3b3;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Playlists Grid */
.playlists-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 24px;
}

.playlist-card {
  background: transparent;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.playlist-card:hover {
  background: #181818;
}

.playlist-image-wrapper {
  position: relative;
  margin-bottom: 16px;
  aspect-ratio: 1;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
}

.playlist-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.playlist-placeholder {
  width: 100%;
  height: 100%;
  background: #282828;
  display: flex;
  align-items: center;
  justify-content: center;
}

.playlist-play-btn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #1db954;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: 0;
  transform: translateY(8px);
  transition: all 0.3s ease;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
}

.playlist-card:hover .playlist-play-btn {
  opacity: 1;
  transform: translateY(0);
}

.playlist-play-btn:hover {
  transform: scale(1.05);
  background: #1ed760;
}

.playlist-play-btn .playlist-play-icon {
  width: 14px;
  height: 14px;
}
.playlist-name {
  font-size: 1rem;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.playlist-description {
  font-size: 0.875rem;
  color: #b3b3b3;
  margin: 0;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
}

/* Empty State */
.search-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  gap: 16px;
  text-align: center;
}

.search-empty-icon {
  width: 64px;
  height: 64px;
  color: #727272;
}

.search-empty h2 {
  font-size: 1.5rem;
  margin: 0;
  color: white;
  font-weight: 700;
}

.search-empty p {
  font-size: 1rem;
  color: #b3b3b3;
  margin: 0;
}

/* Responsive Design */
@media (max-width: 1200px) {
  .artists-grid,
  .albums-grid,
  .playlists-grid {
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
  }
}

@media (max-width: 768px) {
  .search-page {
    padding: 50px 24px;
  }

  .search-input-wrapper {
    max-width: 100%;
  }

  .track-item-album {
    display: none;
  }

  .artists-grid,
  .albums-grid,
  .playlists-grid {
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 16px;
  }
}

@media (max-width: 480px) {
  .search-page {
    padding: 16px;
  }

  .artists-grid,
  .albums-grid,
  .playlists-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
  }
}

/* Add these styles to your Search.css file */

/* Error State Styling */
.search-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 20px;
  text-align: center;
  color: #e74c3c;
}

.error-icon {
  width: 64px;
  height: 64px;
  margin-bottom: 20px;
  color: #e74c3c;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
}

.search-error h3 {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 12px;
  color: #ffffff;
}

.search-error p {
  font-size: 16px;
  color: #9ca3af;
  margin-bottom: 24px;
  max-width: 400px;
}

.retry-btn {
  padding: 12px 32px;
  background: #1ed760;
  color: #000000;
  border: none;
  border-radius: 24px;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s ease;
}

.retry-btn:hover {
  background: #1fdf64;
  transform: scale(1.05);
}

.retry-btn:active {
  transform: scale(0.98);
}

/* Loading State Enhancement */
.search-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 20px;
  text-align: center;
}

.loading-icon {
  width: 64px;
  height: 64px;
  margin-bottom: 20px;
  color: #1ed760;
  animation: spin 2s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.search-loading p {
  font-size: 18px;
  color: #9ca3af;
  font-weight: 500;
}

/* Mobile Responsive Adjustments */
@media (max-width: 768px) {
  .search-error,
  .search-loading {
    padding: 40px 20px;
  }

  .error-icon,
  .loading-icon {
    width: 48px;
    height: 48px;
  }

  .search-error h3 {
    font-size: 20px;
  }

  .search-error p {
    font-size: 14px;
  }

  .retry-btn {
    padding: 10px 24px;
    font-size: 14px;
  }
}
</file>

<file path="src/components/maincontent/Search.jsx">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Search as SearchIcon, Music, User, Disc, List, Play, X, AlertCircle } from 'lucide-react';
import { search, playTrack } from '../../api/spotify';
import './Search.css';

export default function Search({ onPlaylistSelect }) {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [activeFilter, setActiveFilter] = useState('all');
  
  const abortControllerRef = useRef(null);
  const searchCache = useRef(new Map());
  const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

  const performSearch = useCallback(async () => {
    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    const cacheKey = searchQuery.toLowerCase().trim();
    const cached = searchCache.current.get(cacheKey);
    
    // Return cached result if valid
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      setSearchResults(cached.data);
      setLoading(false);
      return;
    }

    // Create new abort controller
    abortControllerRef.current = new AbortController();

    try {
      setLoading(true);
      setError(null);
      
      const results = await search(
        searchQuery, 
        'track,artist,album,playlist', 
        20,
        abortControllerRef.current.signal
      );
      
      // Cache the result
      searchCache.current.set(cacheKey, {
        data: results,
        timestamp: Date.now()
      });
      
      setSearchResults(results);
    } catch (err) {
      if (err.name === 'AbortError') {
        return;
      }
      console.error('Search failed:', err);
      setError(err.message || 'Failed to search. Please try again.');
      setSearchResults(null);
    } finally {
      setLoading(false);
    }
  }, [searchQuery, CACHE_TTL]);

  useEffect(() => {
    let mounted = true;

    if (searchQuery.trim() === '') {
      setSearchResults(null);
      setError(null);
      return;
    }

    const delaySearch = setTimeout(() => {
      if (mounted) {
        performSearch();
      }
    }, 500);

    return () => {
      mounted = false;
      clearTimeout(delaySearch);
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [searchQuery, performSearch]);

  const handleTrackPlay = async (trackId) => {
    try {
        await playTrack(trackId);
    } catch (error) {
        console.error("Error playing track:", error);
    }   
  };

  const clearSearch = () => {
    setSearchQuery('');
    setSearchResults(null);
    setError(null);
  };

  const getFilteredResults = () => {
    if (!searchResults) return null;

    switch (activeFilter) {
      case 'tracks':
        return { tracks: searchResults.tracks };
      case 'artists':
        return { artists: searchResults.artists };
      case 'albums':
        return { albums: searchResults.albums };
      case 'playlists':
        return { playlists: searchResults.playlists };
      default:
        return searchResults;
    }
  };

  const filteredResults = getFilteredResults();

  return (
    <div className="search-page">
      <div className="search-header">
        <div className="search-input-wrapper">
          <SearchIcon className="search-input-icon" />
          <input
            type="text"
            className="search-input"
            placeholder="What do you want to listen to?"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            autoFocus
          />
          {searchQuery && (
            <button className="search-clear-btn" onClick={clearSearch}>
              <X />
            </button>
          )}
        </div>
      </div>

      {/* Search Filters */}
      {searchResults && !error && (
        <div className="search-filters">
          <button
            className={`filter-btn ${activeFilter === 'all' ? 'active' : ''}`}
            onClick={() => setActiveFilter('all')}
          >
            All
          </button>
          <button
            className={`filter-btn ${activeFilter === 'tracks' ? 'active' : ''}`}
            onClick={() => setActiveFilter('tracks')}
          >
            Songs
          </button>
          <button
            className={`filter-btn ${activeFilter === 'artists' ? 'active' : ''}`}
            onClick={() => setActiveFilter('artists')}
          >
            Artists
          </button>
          <button
            className={`filter-btn ${activeFilter === 'albums' ? 'active' : ''}`}
            onClick={() => setActiveFilter('albums')}
          >
            Albums
          </button>
          <button
            className={`filter-btn ${activeFilter === 'playlists' ? 'active' : ''}`}
            onClick={() => setActiveFilter('playlists')}
          >
            Playlists
          </button>
        </div>
      )}

      {/* Error State */}
      {error && (
        <div className="search-error">
          <AlertCircle className="error-icon" />
          <h3>Something went wrong</h3>
          <p>{error}</p>
          <button className="retry-btn" onClick={performSearch}>
            Try Again
          </button>
        </div>
      )}

      {/* Loading State */}
      {loading && (
        <div className="search-loading">
          <Music className="loading-icon" />
          <p>Searching...</p>
        </div>
      )}

      {/* Search Results */}
      {!loading && !error && filteredResults && (
        <div className="search-results">
          {/* Tracks */}
          {filteredResults.tracks?.items && filteredResults.tracks.items.length > 0 && (
            <section className="search-section">
              <h2 className="search-section-title">Songs</h2>
              <div className="tracks-list">
                {filteredResults.tracks.items.map((track) => (
                  <div
                    key={track.id}
                    className="track-item"
                    onClick={() => handleTrackPlay(track.id)}
                  >
                    <div className="track-item-left">
                      <div className="track-item-image">
                        {track.album?.images?.[0] ? (
                          <img src={track.album.images[0].url} alt={track.name} />
                        ) : (
                          <Music className="track-item-icon" />
                        )}
                        <button className="track-item-play-wrapper">
                          <Play className="songs-play-icon" fill="#eeededff" stroke='#eeededff' />
                        </button>
                      </div>
                      <div className="track-item-info">
                        <h3 className="track-item-name">{track.name}</h3>
                        <p className="track-item-artist">
                          {track.artists?.map(a => a.name).join(', ')}
                        </p>
                      </div>
                    </div>
                    <p className="track-item-album">{track.album?.name}</p>
                  </div>
                ))}
              </div>
            </section>
          )}

          {/* Artists */}
          {filteredResults.artists?.items && filteredResults.artists.items.length > 0 && (
            <section className="search-section">
              <h2 className="search-section-title">Artists</h2>
              <div className="artists-grid">
                {filteredResults.artists.items.map((artist) => (
                  <div key={artist.id} className="artist-card">
                    <div className="artist-image-wrapper">
                      {artist.images?.[0] ? (
                        <img
                          src={artist.images[0].url}
                          alt={artist.name}
                          className="artist-image"
                        />
                      ) : (
                        <div className="artist-placeholder">
                          <User className="placeholder-icon" />
                        </div>
                      )}
                    </div>
                    <h3 className="artist-name">{artist.name}</h3>
                    <p className="artist-type">Artist</p>
                  </div>
                ))}
              </div>
            </section>
          )}

          {/* Albums */}
          {filteredResults.albums?.items && filteredResults.albums.items.length > 0 && (
            <section className="search-section">
              <h2 className="search-section-title">Albums</h2>
              <div className="albums-grid">
                {filteredResults.albums.items.map((album) => (
                  <div key={album.id} className="album-card">
                    <div className="album-image-wrapper">
                      {album.images?.[0] ? (
                        <img
                          src={album.images[0].url}
                          alt={album.name}
                          className="album-image"
                        />
                      ) : (
                        <div className="album-placeholder">
                          <Disc className="placeholder-icon" />
                        </div>
                      )}
                      <button className="album-play-btn">
                        <Play className="album-play-icon" fill="black" />
                      </button>
                    </div>
                    <h3 className="album-name">{album.name}</h3>
                    <p className="album-artist">
                      {album.artists?.map(a => a.name).join(', ')}
                    </p>
                  </div>
                ))}
              </div>
            </section>
          )}

          {/* Playlists */}
          {filteredResults.playlists?.items && filteredResults.playlists.items.length > 0 && (
            
            <section className="search-section">
              <h2 className="search-section-title">Playlists</h2>
              <div className="playlists-grid">
                {filteredResults.playlists.items.map((playlist) => (
                  <div
                    key={playlist?.id}
                    className="playlist-card"
                    onClick={() => onPlaylistSelect && onPlaylistSelect(playlist)}
                  >
                    <div className="playlist-image-wrapper">
                      {playlist?.images?.[0]?.url ? (
                        <img
                          src={playlist.images[0].url}
                          alt={playlist.name}
                          className="playlist-image"
                        />
                      ) : (
                        <div className="playlist-placeholder">
                          <List className="placeholder-icon" />
                        </div>
                      )}
                      <button className="playlist-play-btn">
                        <Play className="playlist-play-icon" fill="black" />
                      </button>
                    </div>
                    <h3 className="playlist-name">{playlist?.name}</h3>
                    <p className="playlist-description">
                      {playlist?.description?.replace(/<[^>]*>/g, '') || 'Playlist'}
                    </p>
                  </div>
                ))}
              </div>
            </section>
          )}
        </div>
      )}

      {/* Empty State - No Search */}
      {!searchQuery && !searchResults && !error && (
        <div className="search-empty">
          <SearchIcon className="search-empty-icon" />
          <h2>Search for songs, artists, albums, and more</h2>
        </div>
      )}

      {/* No Results */}
      {!loading && !error && searchQuery && searchResults && (
        <>
          {(!filteredResults.tracks?.items?.length &&
            !filteredResults.artists?.items?.length &&
            !filteredResults.albums?.items?.length &&
            !filteredResults.playlists?.items?.length) && (
            <div className="search-empty">
              <SearchIcon className="search-empty-icon" />
              <h2>No results found for "{searchQuery}"</h2>
              <p>Try searching for something else</p>
            </div>
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="src/components/player/GetTrackDetails.jsx">
export function getTrackDetailsFromState(state) {
  if (!state?.item) {
    return null; // Nothing is playing
  }

  return {
    id: state.item.id,
    name: state.item.name,
    artists: state.item.artists.map(a => a.name).join(', '),
    album: state.item.album.name,
    albumArt: state.item.album.images?.[0]?.url || null,
    durationMs: state.item.duration_ms,
    progressMs: state.progress_ms,
    isPlaying: state.is_playing,
    uri: state.item.uri
  };
}
</file>

<file path="src/components/player/Player.css">
.player {
  height: 96px;
  background-color: #181818;
  border-top: 1px solid #282828;
  padding: 0 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.player-left {
  display: flex;
  align-items: center;
  gap: 16px;
  flex: 1;
  min-width: 180px;
}

.current-track-image {
  width: 56px;
  height: 56px;
  background-color: #282828;
  border-radius: 4px;
  flex-shrink: 0;
}

.current-track-image img {
  width: 56px;
  height: 56px;
  border-radius: 4px;
}

.current-track-info {
  display: flex;
  flex-direction: column;
  justify-content: center;
  overflow: hidden;
  flex: 1;
  min-width: 0;
}

.track-carousel {
  display: flex;
  flex-direction: column;
  gap: 2px; 
}

.current-track-title {
  font-size: 14px;
  font-weight: 500;
  color: #ffffff;
  line-height: 1.2;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.current-track-artist {
  font-size: 12px;
  font-weight: 400;
  color: #b3b3b3;
  line-height: 1.2;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.track-separator {
  display: none;
}

.player-heart {
  width: 20px;
  height: 20px;
  color: #b3b3b3;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}
.track-separator{
  display: none;
}
.player-heart:hover {
  color: #1db954;
  transform: scale(1.2);
  stroke: #1db954;
  fill: #1db954;
}

@keyframes heartbeat {
  0% { transform: scale(1); }
  50% { transform: scale(1.4); }
  100% { transform: scale(1); }
}

.player-center {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
  max-width: 722px;
  padding: 0 24px;
}

.player-controls {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 8px;
}

.control-icon {
  width: 20px;
  height: 20px;
  color: #b3b3b3;
  fill: #b3b3b3;
  cursor: pointer;
  transition: color 0.2s;
}

.control-icon:hover {
  color: white;
  fill: white;
}

.play-button {
  width: 32px;
  height: 32px;
  background-color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: none;
  cursor: pointer;
  transition: transform 0.2s;
}

.play-button:hover {
  transform: scale(1.1);
}

.play-iconn {
  width: 16px;
  height: 16px;
  color: #181818;
  fill: #181818;
}

.play-icon-offset {
  margin-left: 2px;
}

.progress-container {
  display: flex;
  align-items: center;
  gap: 12px;
  width: 100%;
  padding: 0 8px;
}

.progress-time {
  font-size: 12px;
  color: #b3b3b3;
  font-weight: 400;
  min-width: 40px;
  text-align: center;
}

.progress-bar-wrapper {
  position: relative;
  flex: 1;
  height: 12px;
  display: flex;
  align-items: center;
  cursor: pointer;
}

.progress-track {
  position: absolute;
  width: 100%;
  height: 4px;
  background-color: #4d4d4d;
  border-radius: 2px;
  pointer-events: none;
}

.progress-fill {
  position: absolute;
  height: 4px;
  background-color: #fff;
  border-radius: 2px;
  pointer-events: none;
  transition: background-color 0.2s ease;
  z-index: 1;
}

.progress-bar-wrapper:hover .progress-fill {
  background-color: #1db954;
}

.progress-seek {
  position: absolute;
  width: 100%;
  height: 12px;
  opacity: 0;
  cursor: pointer;
  z-index: 2;
  margin: 0;
  appearance: none;
}

.progress-seek::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  cursor: pointer;
}

.progress-seek::-moz-range-thumb {
  width: 12px;
  height: 12px;
  cursor: pointer;
  border: none;
  background: transparent;
}

.progress-bar-wrapper:hover .progress-fill::after {
  content: '';
  position: absolute;
  right: -6px;
  top: 50%;
  transform: translateY(-50%);
  width: 12px;
  height: 12px;
  background-color: #fff;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.player-right {
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 1;
  justify-content: flex-end;
  min-width: 180px;
}

.volume-icon {
  width: 20px;
  height: 20px;
  color: #b3b3b3;
}

.volume-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 100px;
  height: 4px;
  background: transparent;
  overflow: hidden;
  cursor: pointer;
  --fill-percent: 50%;
  background: linear-gradient(
    to right,
    white 0%,
    white var(--fill-percent),
    #535353 var(--fill-percent),
    #535353 100%
  );
  border-radius: 2px;
}

.volume-slider:hover {
  background: linear-gradient(
    to right,
    #1db954,
    #1db954 var(--fill-percent),
    #535353 var(--fill-percent),
    #535353 100%
  );
  overflow: visible;
}

.volume-slider::-webkit-slider-runnable-track {
  height: 4px;
  border-radius: 2px;
}

.volume-slider::-moz-range-track {
  height: 4px;
  border-radius: 2px;
}

.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-top: -4px;
}

.volume-slider::-moz-range-thumb {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: none;
}

.volume-slider::-webkit-slider-thumb:hover {
  border-radius: 50%;
  background: #ffffff;
}

.volume-slider::-moz-range-thumb:hover {
  border-radius: 50%;
  background: #ffffff;
}
/* here */
/* ===== TABLET RESPONSIVENESS (768px - 1024px) ===== */
@media (max-width: 1024px) {
  .player-center {
    padding: 0 16px;
    min-width: 400px;
  }

  .progress-container {
    gap: 10px;
  }
  .track-separator{
    display: none;
  }
}

/* ===== TABLET & MOBILE RESPONSIVENESS (768px and below) ===== */
@media (max-width: 768px) {
  .player {
    height: 90px;
    padding: 0 12px;
    position: fixed;
    z-index: 100;
    bottom: 11%;
    width: 100%;
    left: 0;
  }
  .track-separator{
    display: none;
  }
  /* Left section - keep as is */
  .player-left {
    gap: 12px;
    min-width: 140px;
    flex: 0.8;
  }

  .current-track-image {
    width: 48px;
    height: 48px;
  }

  .current-track-image img {
    width: 48px;
    height: 48px;
  }

  .current-track-info {
    max-width: 180px;
    overflow: hidden;
    white-space: nowrap;
  }

  .track-carousel {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    animation: scroll-carousel 12s linear infinite;
  }

  .current-track-title {
    font-size: 13px;
    font-weight: 600;
    white-space: nowrap;
  }

  .current-track-artist {
    font-size: 11px;
    white-space: nowrap;
  }

  .track-separator {
    display: inline;
    color: #b3b3b3;
    font-size: 12px;
  }

  @keyframes scroll-carousel {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
  }

  .current-track-info {
    mask-image: linear-gradient(
      to right,
      transparent,
      black 10%,
      black 90%,
      transparent
    );
  }

  /* Heart button - make more prominent */
  .player-heart {
    width: 18px;
    height: 18px;
    margin-left: 4px;
  }

  /* Center section - optimize for mobile */
  .player-center {
    flex: 1.5;
    padding: 0 12px;
    max-width: 500px;
    min-width: 250px;
  }

  .player-controls {
    gap: 12px;
    margin-bottom: 6px;
  }
  .track-separator{
    display: none;
  }
  .control-icon {
    width: 18px;
    height: 18px;
  }

  .play-button {
    width: 30px;
    height: 30px;
  }

  .play-iconn {
    width: 14px;
    height: 14px;
  }

  /* Progress bar - more touch-friendly */
  .progress-container {
    gap: 8px;
    padding: 0 4px;
  }

  .progress-time {
    font-size: 11px;
    min-width: 35px;
    font-weight: 500;
  }

  .progress-bar-wrapper {
    height: 20px;
    touch-action: none;
  }

  .progress-track {
    height: 3px;
  }

  .progress-fill {
    height: 3px;
  }

  .progress-seek {
    height: 20px;
  }

  .progress-seek::-webkit-slider-thumb {
    width: 16px;
    height: 16px;
  }

  .progress-seek::-moz-range-thumb {
    width: 16px;
    height: 16px;
  }

  /* Right section - keep volume as is */
  .player-right {
    min-width: 80px;
    max-width: 110px;
    flex: 0.7;
  }

  .volume-slider {
    width: 70px;
  }
}

/* ===== MOBILE RESPONSIVENESS (480px and below) ===== */
@media (max-width: 480px) {
  .player {
    height: 85px;
    padding: 0 10px;
  }
  .track-separator{
    display: none;
  }
  /* Left section */
  .player-left {
    gap: 10px;
    min-width: 110px;
    flex: 0.7;
  }

  .current-track-image {
    width: 44px;
    height: 44px;
  }

  .current-track-image img {
    width: 44px;
    height: 44px;
  }

  .current-track-info {
    max-width: 140px;
  }

  .current-track-title {
    font-size: 12px;
  }

  .current-track-artist {
    font-size: 10px;
  }

  .track-separator {
    font-size: 11px;
  }

  /* Heart button */
  .player-heart {
    width: 16px;
    height: 16px;
    margin-left: 2px;
  }

  /* Center section */
  .player-center {
    flex: 1.8;
    padding: 0 8px;
    min-width: 180px;
  }

  .player-controls {
    gap: 10px;
    margin-bottom: 4px;
  }

  .control-icon {
    width: 16px;
    height: 16px;
  }

  .play-button {
    width: 28px;
    height: 28px;
  }

  .play-iconn {
    width: 13px;
    height: 13px;
  }

  /* Progress bar - even more touch-friendly */
  .progress-container {
    gap: 6px;
    padding: 0 2px;
  }

  .progress-time {
    font-size: 10px;
    min-width: 32px;
  }

  .progress-bar-wrapper {
    height: 24px;
  }

  .progress-track {
    height: 3px;
  }

  .progress-fill {
    height: 3px;
  }

  .progress-seek {
    height: 24px;
  }

  .progress-seek::-webkit-slider-thumb {
    width: 18px;
    height: 18px;
  }

  .progress-seek::-moz-range-thumb {
    width: 18px;
    height: 18px;
  }

  /* Right section */
  .player-right {
    min-width: 40px;
    max-width: 80px;
    gap: 8px;
    flex: 0.6;
  }

  .volume-icon {
    width: 18px;
    height: 18px;
  }

  .volume-slider {
    width: 60px;
  }
}

/* ===== EXTRA SMALL MOBILE (380px and below) ===== */
@media (max-width: 380px) {
  .player {
    height: 80px;
    padding: 0 8px;
  }

  /* Left section */
  .player-left {
    gap: 8px;
    min-width: 100px;
    flex: 0.6;
  }
  .track-separator{
    display: none;
  }
  .current-track-image {
    width: 40px;
    height: 40px;
  }

  .current-track-image img {
    width: 40px;
    height: 40px;
  }

  .current-track-info {
    max-width: 120px;
  }

  .current-track-title {
    font-size: 11px;
  }

  .current-track-artist {
    font-size: 9px;
  }

  .player-heart {
    width: 14px;
    height: 14px;
  }

  /* Center section */
  .player-center {
    flex: 2;
    padding: 0 6px;
    min-width: 180px;
  }

  .player-controls {
    gap: 8px;
    margin-bottom: 3px;
  }

  .control-icon {
    width: 14px;
    height: 14px;
  }

  .play-button {
    width: 26px;
    height: 26px;
  }

  .play-iconn {
    width: 12px;
    height: 12px;
  }

  /* Progress bar */
  .progress-container {
    gap: 4px;
    padding: 0;
  }

  .progress-time {
    font-size: 9px;
    min-width: 30px;
  }

  .progress-bar-wrapper {
    height: 26px;
  }

  .progress-seek::-webkit-slider-thumb {
    width: 20px;
    height: 20px;
  }

  .progress-seek::-moz-range-thumb {
    width: 20px;
    height: 20px;
  }

  /* Right section */
  .player-right {
    min-width: 60px;
    max-width: 90px;
    gap: 6px;
    flex: 0.5;
  }

  .volume-icon {
    width: 16px;
    height: 16px;
  }

  .volume-slider {
    width: 50px;
  }
}
</file>

<file path="src/components/player/Player.jsx">
import React, { useState, useEffect } from 'react';
import { Play, Pause, SkipBack, SkipForward, Volume2, Heart } from 'lucide-react';
import './Player.css';
import {
  getPlayerState,
  togglePlayback,
  skipToNext,
  skipToPrevious,
  setVolume,
  unlikeTrack,
  likeTrack,
  checkTracksLiked,
  seekToPosition } from '../../api/spotify';
import { getTrackDetailsFromState } from './GetTrackDetails';

function Player() {
  const [track, setTrack] = useState(null);
  const [isLiked, setIsLiked] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [volume, setVolumeState] = useState(50);
  const [seekValue, setSeekValue] = useState(0);
  const [isSeeking, setIsSeeking] = useState(false);

  useEffect(() => {
    const fetchPlayerState = async () => {
      try {
        const state = await getPlayerState();

        const trackDetails = getTrackDetailsFromState(state);
        setTrack(trackDetails);

        // Sync volume
        if (state?.device?.volume_percent !== undefined) {
          setVolumeState(state.device.volume_percent);
        }

        // Sync progress only when not actively seeking
        if (!isSeeking && trackDetails?.progressMs !== undefined) {
          setSeekValue(trackDetails.progressMs);
        }

        setError(null);
      } catch (err) {
        console.error('Failed to get player state:', err);
        setError('Could not load player state');
      } finally {
        setLoading(false);
      }
    };

    fetchPlayerState();
    const interval = setInterval(fetchPlayerState, 2000);
    return () => clearInterval(interval);
  }, [isSeeking]);

  useEffect(() => {
    if (!track?.id) {
      setIsLiked(false);
      return;
    }

    async function checkLiked() {
      try {
        const results = await checkTracksLiked(track.id);
        setIsLiked(results[0]);
      } catch (err) {
        console.error('Failed to check liked status:', err);
      }
    }

    checkLiked();
  }, [track?.id]);

  const handleLikeToggle = async () => {
    if (!track?.id) return;
    setLoading(true);
    try {
      if (isLiked) {
        await unlikeTrack(track.id);
      } else {
        await likeTrack(track.id);
      }
      setIsLiked(!isLiked);
    } catch (err) {
      console.error('Failed to update like status', err);
    } finally {
      setLoading(false);
    }
  };

  const handleToggle = async () => {
    if (!track) return;
    try {
      await togglePlayback();
      const state = await getPlayerState();
      setTrack(getTrackDetailsFromState(state));
    } catch (err) {
      console.error('Play/pause failed:', err);
    }
  };

  const handlePrevious = async () => {
    try {
      await skipToPrevious();
      await new Promise((res) => setTimeout(res, 300));
      const state = await getPlayerState();
      setTrack(getTrackDetailsFromState(state));
    } catch (err) {
      console.error('Previous failed:', err);
      alert('Could not go to previous track. Make sure something is playing.');
    }
  };

  const handleNext = async () => {
    try {
      await skipToNext();
      await new Promise((res) => setTimeout(res, 300));
      const state = await getPlayerState();
      setTrack(getTrackDetailsFromState(state));
    } catch (err) {
      console.error('Next failed:', err);
      alert('Could not skip to next track. Make sure something is playing.');
    }
  };

  const handleVolumeChange = async (e) => {
    const newVolume = Number(e.target.value);
    setVolumeState(newVolume);

    try {
      await setVolume(newVolume);
    } catch (err) {
      console.error('Volume update failed', err);
      // Re-sync on failure
      const state = await getPlayerState();
      if (state?.device?.volume_percent !== undefined) {
        setVolumeState(state.device.volume_percent);
      }
    }
  };

  const handleSeekChange = (e) => {
    const newPos = Number(e.target.value);
    setSeekValue(newPos);
  };

  const handleSeekMouseDown = () => {
    setIsSeeking(true);
  };

  const handleSeekMouseUp = async (e) => {
    setIsSeeking(false);
    const newPos = Number(e.target.value);

    try {
      await seekToPosition(newPos);
      const state = await getPlayerState();
      const trackDetails = getTrackDetailsFromState(state);
      setTrack(trackDetails);
      setSeekValue(trackDetails.progressMs);
    } catch (err) {
      console.error('Seek failed:', err);
      // Re-sync on error
      const state = await getPlayerState();
      const trackDetails = getTrackDetailsFromState(state);
      setTrack(trackDetails);
      setSeekValue(trackDetails.progressMs);
    }
  };

  const formatTime = (ms) => {
    if (ms === undefined || ms === null) return '0:00';
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  if (loading) {
    return <div className="player-loading"></div>;
  }

  if (error) {
    return <div className="player-error">{error}</div>;
  }

  if (!track) {
    return (
      <div className="player player-empty">
        <p></p>
      </div>
    );
  }

  const progressPercent = track.durationMs ? (seekValue / track.durationMs) * 100 : 0;

  return (
    <div className="player" key={track.id}>
      {/* Left: Album art, title, heart */}
      <div className="player-left">
        <div className="current-track-image">
          {track.albumArt ? (
            <img src={track.albumArt} alt="Album cover" />
          ) : (
            <div className="no-image" />
          )}
        </div>

        <div className="current-track-info">
          <div className="track-carousel">
            <span className="current-track-title">{track.name}</span>
            <span className="track-separator"> â€¢ </span>
            <span className="current-track-artist">{track.artists}</span>
          </div>
        </div>

        <Heart
          className={`player-heart ${isLiked ? 'liked' : ''}`}
          onClick={handleLikeToggle}
          disabled={loading}
          fill={isLiked ? '#1db954' : 'none'}
          stroke={isLiked ? '#1db954' : '#b3b3b3'}
        />
      </div>

      {/* Center: Controls + Seek bar */}
      <div className="player-center">
        <div className="player-controls">
          <SkipBack className="control-icon" onClick={handlePrevious} />
          <button onClick={handleToggle} className="play-button">
            {track.isPlaying ? (
              <Pause className="play-iconn pause" />
            ) : (
              <Play className="play-iconn play-icon-offset" />
            )}
          </button>
          <SkipForward className="control-icon" onClick={handleNext} />
        </div>

        <div className="progress-container">
          <span className="progress-time">{formatTime(seekValue)}</span>

          <div className="progress-bar-wrapper">
            <div className="progress-track" />
            <div
              className="progress-fill"
              style={{ width: `${progressPercent}%` }}
            />
            <input
              type="range"
              min="0"
              max={track.durationMs || 0}
              value={seekValue}
              onChange={handleSeekChange}
              onMouseDown={handleSeekMouseDown}
              onMouseUp={handleSeekMouseUp}
              onTouchStart={handleSeekMouseDown}
              onTouchEnd={handleSeekMouseUp}
              className="progress-seek"
              step="1000"
            />
          </div>

          <span className="progress-time">{formatTime(track.durationMs)}</span>
        </div>
      </div>

      {/* Right: Volume */}
      <div className="player-right">
        <Volume2 className="volume-icon" />
        <input
          type="range"
          min="0"
          max="100"
          value={volume}
          onChange={handleVolumeChange}
          className="volume-slider"
          style={{ '--fill-percent': `${volume}%` }}
        />
      </div>
    </div>
  );
}

export default Player;
</file>

<file path="src/components/sidebar/Sidebar.css">
.sidebar {
  width: 256px;
  background-color: #000;
  color: white;
  padding: 24px;
  display: flex;
  flex-direction: column;
}
#show-create-playlist{
  display: flex;
}
.sidebar-logo {
  margin-bottom: 32px;
}

.logo-icon {
  width: 40px;
  height: 40px;
  color: #1db954;
}

.sidebar-nav {
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-bottom: 32px;
}

.nav-button {
  display: flex;
  align-items: center;
  gap: 12px;
  color: #b3b3b3;
  background: none;
  border: none;
  cursor: pointer;
  transition: color 0.2s;
  padding: 0;
  font-size: 14px;
  font-weight: 600;
}

.nav-button:hover {
  color: white;
}
#create-playlist{
  display: none;
}
.nav-icon {
  width: 24px;
  height: 24px;
}

.sidebar-actions {
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-bottom: 32px;
}

.playlist-section {
  border-top: 1px solid #282828;
  padding-top: 16px;
  flex: 1;
  overflow-y: auto;
}

.playlist-section::-webkit-scrollbar {
  display: none;
}

.playlist-item {
  display: flex;
  align-items: center;
  gap: 12px;
  color: #b3b3b3;
  background: none;
  border: none;
  cursor: pointer;
  padding: 8px 0;
  font-size: 14px;
  width: 100%;
  text-align: left;
  transition: color 0.2s;
}

.playlist-item:hover {
  color: white;
}

.playlist-item:hover .playlist-subtitle {
  color: #b3b3b3; 
}

.playlist-item-image {
  width: 40px;
  height: 40px;
  flex-shrink: 0;
  border-radius: 4px;
  overflow: hidden;
  background-color: #282828;
}

.playlist-item-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.playlist-item-image-placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  color: #b3b3b3;
}

.playlist-item-info {
  display: flex;
  flex-direction: column;
  min-width: 0; 
}

.playlist-item-name {
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.playlist-subtitle {
  font-size: 12px;
  color: #b3b3b3;
  transition: color 0.2s;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.spotify-logout-btn {
  display: flex;
  align-items: center;
  gap: 10px;
  width: 100%;
  margin-top: auto;
  padding: 12px 16px;
  background: transparent;
  border: none;
  border-radius: 4px;
  color: #b3b3b3;
  font-size: 14px;
  font-weight: 500;
  text-align: left;
  cursor: pointer;
  transition: color 0.2s ease, background-color 0.2s ease;
}

.spotify-logout-btn:hover {
  color: #1db954;
}

.spotify-logout-btn:active {
  background-color: rgba(255, 255, 255, 0.15);
}

.spotify-logout-btn:focus-visible {
  outline: 2px solid #1db954;
  outline-offset: 2px;
}

.logout-icon {
  font-size: 16px;
  line-height: 1;
  flex-shrink: 0;
  color: inherit;
}

.playlist-header {
  padding-bottom: 8px;
  font-weight: 500;
  font-size: 18px;
  color: #b3b3b3;
}

@media (max-width: 770px) {
  .sidebar-logo, .playlist-section, .playlist-header{
    display: none;
  }
  .sidebar-actions{
      display: none;
    }
  .spotify-logout-btn{
      display: none;
    }
    #create-playlist{
      display: flex;
      flex-direction: column;
      width: 150px;
    }
  .sidebar{
    position: fixed;
    bottom: 0;
    z-index: 100;
    background-color: rgba(1, 1, 1, 0.13);     /* Dark semi-transparent background (adjust alpha for more/less transparency) */
    backdrop-filter: blur(12px);              /* The key: blurs whatever is behind the element, creating the frosted glass look */
    -webkit-backdrop-filter: blur(12px);      /* Required for Safari/iOS support */ 
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);  /* Subtle white glow line at the bottom */
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    width: 100%;
    height: 90px;
  }
  @supports not (backdrop-filter: blur(10px)) {
  .overlay-bar {
    background-color: rgba(0, 0, 0, 0.6); /* Just more opaque if no blur */
  }
}
  .sidebar-nav{
    flex-direction: row;
    width: 100%;
    justify-content: space-evenly;
  }
  .nav-button{
    display: flex;
    flex-direction: column;
    width: 150px;
    font-size: 13px;
  }
  #show-create-playlist{
    display: none;
  }
}
</file>

<file path="src/components/sidebar/Sidebar.jsx">
import React from 'react';
import { Music, Home, Search, Library, Plus, Heart, LogOut } from 'lucide-react';
import './Sidebar.css';
import { getPlaylistTracks } from '../../api/spotify';

export default function Sidebar({ playlists, setCurrentView, onLogout, onPlaylistSelect }) {

  const handlePlaylistClick = async (playlistId, playlistName, playlistImage, playlistType, playlistTotal, playlistDisplayName) => {
    try {
      const tracksData = await getPlaylistTracks(playlistId);
      onPlaylistSelect(tracksData, playlistName, playlistId, playlistImage, playlistType, playlistTotal, playlistDisplayName);
      setCurrentView("playlist");
    } catch (error) {
      console.error('Error fetching tracks:', error);
    }
  };

  const getSubtitle = (playlist) => {
    if (playlist.type === 'album') {
      return `Album â€¢ ${playlist.artists?.[0]?.name || 'Unknown Artist'}`;
    }
    return `Playlist â€¢ ${playlist.owner?.display_name || 'You'}`;
  };

  return (
    <div className="sidebar">
      <div className="sidebar-logo">
        <Music className="logo-icon" />
      </div>
      <div className='sidebar-all-action'>
        <nav className="sidebar-nav">
          <button 
            onClick={() => setCurrentView('home')}
            className="nav-button"
          >
            <Home className="nav-icon" />
            <span>Home</span>
          </button>
          <button 
            onClick={() => setCurrentView('search')}
            className="nav-button"
          >
            <Search className="nav-icon" />
            <span>Search</span>
          </button>
          <button className="nav-button"
          onClick={() => setCurrentView("library")}>
            <Library className="nav-icon" />
            <span>Your Library</span>
          </button>
          <button className="nav-button"
          id='create-playlist'>
            <Plus className="nav-icon" />
            <span>Create Playlist</span>
          </button>
        </nav>

        <div className="sidebar-actions">
          <button className="nav-button" 
          id='show-create-playlist'>
            <Plus className="nav-icon" />
            <span>Create Playlist</span>
          </button>
          <button className="nav-button"
          id='liked-nav-buttonn'
          onClick={() => setCurrentView("liked")}>
            <Heart className="nav-icon" />
            <span>Liked Songs</span>
          </button>
        </div>
      </div>
      <div className="playlist-header">
        <p>My Playlists</p>
      </div>

      <div className="playlist-section">
        {playlists.map((playlist) => {
          const imageUrl = playlist.images?.[0]?.url || playlist.images?.url; // Handle both array and object

          return (
            <button
              key={playlist.id}
              className="playlist-item"
              onClick={() =>
                handlePlaylistClick(
                  playlist.id,
                  playlist.name,
                  playlist.images,
                  playlist.type,
                  playlist.tracks?.total,
                  playlist.owner?.display_name
                )
              }
            >
              <div className="playlist-item-image">
                {imageUrl ? (
                  <img
                    src={imageUrl}
                    alt={`${playlist.name} cover`}
                    onError={(e) => {
                      e.target.style.display = 'none';
                      e.target.nextSibling.style.display = 'flex'; // Show placeholder if exists
                    }}
                  />
                ) : null}
                <div className="playlist-item-image-placeholder" style={{ display: imageUrl ? 'none' : 'flex' }}>
                  <span>â™ª</span>
                </div>
              </div>

              <div className="playlist-item-info">
                <span className="playlist-item-name">{playlist.name}</span>
                <span className="playlist-subtitle">{getSubtitle(playlist)}</span>
              </div>
            </button>
          );
        })}
      </div>

      <div>
        <button onClick={onLogout} className="spotify-logout-btn">
          <LogOut size={16} strokeWidth={2} className="logout-icon" />
          Log out
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/userdetails/LikedSongs.css">
.likedsongs-view {
  min-height: 100vh;
  background: linear-gradient(to bottom, #5b21b6 0%, #2e1065 25%, #1a0b2e 50%, #0a0118 100%);
  color: white;
  padding-bottom: 100px;
  width: 100%;
  overflow-y: auto;
  scroll-behavior: smooth;
}

.likedsongs-view::-webkit-scrollbar {
  width: 12px;
}

.likedsongs-view::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.03);
}

.likedsongs-view::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 6px;
}

.likedsongs-view::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

.likedsongs-header {
  display: flex;
  align-items: flex-end;
  gap: 32px;
  padding: 80px 32px 24px;
  min-height: 340px;
  position: relative;
}

.likedsongs-cover-shadow {
  flex-shrink: 0;
  width: 232px;
  height: 232px;
  border-radius: 12px;
  background: linear-gradient(135deg, #7c3aed, #a78bfa);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 24px rgba(124, 58, 237, 0.4), 0 16px 48px rgba(0, 0, 0, 0.6);
}

.likedsongs-cover {
  width: 200px;
  height: 200px;
  background: linear-gradient(135deg, rgba(30, 215, 96, 0.15), rgba(124, 58, 237, 0.15));
  backdrop-filter: blur(10px);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.likedsongs-info {
  flex: 1;
  min-width: 0;
}

.playlist-badge {
  font-size: 12px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  margin-bottom: 12px;
  display: block;
  opacity: 0.9;
}

.likedsongs-title {
  font-size: clamp(32px, 8vw, 96px);
  font-weight: 900;
  line-height: 1;
  margin: 0 0 24px 0;
  letter-spacing: -0.04em;
  text-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.likedsongs-description {
  font-size: clamp(14px, 2vw, 16px);
  color: #d1d5db;
  margin: 0;
  font-weight: 500;
}

.likedsongs-controls {
  padding: 32px 32px 24px;
  display: flex;
  align-items: center;
  gap: 24px;
}

.play-button-large {
  width: 64px;
  height: 64px;
  background: #1ed760;
  border: none;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(30, 215, 96, 0.4);
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
}

.play-button-large::before {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  opacity: 0;
  transition: opacity 0.2s;
}

.play-button-large:hover {
  transform: scale(1.06);
  background: #1fdf64;
}

.play-button-large:hover::before {
  opacity: 1;
}

.play-button-large:active {
  transform: scale(0.98);
}

.more-button {
  background: none;
  border: none;
  color: #9ca3af;
  cursor: pointer;
  padding: 8px;
  border-radius: 50%;
  transition: all 0.2s;
}

.more-button:hover {
  color: white;
  background: rgba(255, 255, 255, 0.1);
}

.likedsongs-tracks {
  background: transparent;
  margin: 0 32px;
  border-radius: 8px;
  overflow: hidden;
}

.tracks-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
  table-layout: fixed;
}

.tracks-table thead {
  position: sticky;
  top: 0;
  background: rgba(10, 1, 24, 0.95);
  backdrop-filter: blur(10px);
  z-index: 10;
}

.tracks-table th {
  text-align: left;
  padding: 12px 16px;
  color: #9ca3af;
  font-weight: 400;
  text-transform: uppercase;
  font-size: 11px;
  letter-spacing: 1.5px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.tracks-table th.duration-col {
  padding-right: 32px !important;
}

.index-col { 
  width: 60px; 
  text-align: center;
  padding-left: 16px !important;
}

.title-col {
  width: 50%;
  min-width: 200px;
}

.album-col { 
  width: 30%;
  max-width: 300px;
}

.duration-col { 
  width: 140px; 
  text-align: right; 
  padding-right: 32px !important;
}

.track-row {
  height: 64px;
  transition: background 0.2s ease;
  border-bottom: 1px solid rgba(255, 255, 255, 0.03);
}

.track-row:hover {
  background: rgba(255, 255, 255, 0.08);
  border-radius: 4px;
}

.track-row.playing {
  background: rgba(124, 58, 237, 0.15);
}

.track-row td {
  padding: 8px 16px;
  vertical-align: middle;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.play-pause-btn {
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  padding: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.2s;
}

.play-pause-btn:hover {
  transform: scale(1.1);
}

.track-index {
  color: #9ca3af;
  font-size: 14px;
}

.title-wrapper {
  display: flex;
  align-items: center;
  gap: 12px;
  min-width: 0;
}

.title-wrapper img {
  width: 40px;
  height: 40px;
  border-radius: 4px;
  object-fit: cover;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  flex-shrink: 0;
}

.mini-placeholder {
  width: 40px;
  height: 40px;
  background: linear-gradient(135deg, #374151, #1f2937);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6b7280;
  font-size: 18px;
  border-radius: 4px;
  flex-shrink: 0;
}

.title-wrapper > div {
  min-width: 0;
  flex: 1;
}

.track-name {
  font-weight: 500;
  font-size: 15px;
  color: #ffffff;
  margin-bottom: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.track-name.now-playing {
  color: #1ed760;
}

.artists {
  color: #9ca3af;
  font-size: 13px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.album-col {
  color: #9ca3af;
  font-size: 14px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  padding-right: 16px !important;
}

.duration-col {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 12px;
  padding-right: 32px !important;
}

.duration {
  color: #9ca3af;
  font-size: 14px;
  min-width: 40px;
  text-align: right;
}

.like-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 8px;
  border-radius: 50%;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  opacity: 0.7;
  flex-shrink: 0;
}

.like-btn:hover {
  transform: scale(1.15);
  opacity: 1;
  background: rgba(255, 255, 255, 0.1);
}

.loading-message,
.empty-message {
  text-align: center;
  padding: 80px 20px;
  color: #9ca3af;
  font-size: 16px;
  font-weight: 500;
}

.liked-tracks-wrapper {
  display: contents;
}
@media (max-width: 1224px) {
  .title-col {
    width: 42%;
  }
}
/* ===== TABLET RESPONSIVENESS (768px - 1024px) ===== */
@media (max-width: 1024px) {
  .likedsongs-tracks {
    margin: 0 24px;
  }

  .album-col { 
    width: 25%;
    max-width: 250px;
  }
  .title-col {
    width: 68%;
    min-width: 150px;
  }
  .duration-col { 
    width: 130px; 
  }
  .tracks-table th.album-col,
  .tracks-table td.album-col {
    display: none;
  }
}
@media (max-width: 924px) {
  .title-col {
    width: 62%;
  }
}
/* ===== TABLET RESPONSIVENESS (768px and below) ===== */
@media (max-width: 768px) {
  .likedsongs-header {
    flex-direction: column;
    align-items: center;
    text-align: center;
    padding: 40px 20px 24px;
    min-height: auto;
  }

  .likedsongs-cover-shadow {
    width: 180px;
    height: 180px;
  }

  .likedsongs-cover {
    width: 160px;
    height: 160px;
  }
  
  .likedsongs-cover svg {
    width: 64px;
    height: 64px;
  }

  .likedsongs-controls {
    padding: 24px 20px;
    justify-content: center;
  }

  .likedsongs-tracks {
    margin: 0 20px;
  }

  /* Hide album column on tablet and mobile */
  .tracks-table th.album-col,
  .tracks-table td.album-col {
    display: none;
  }

  .tracks-table th {
    padding: 12px 12px;
    font-size: 10px;
  }

  .track-row {
    height: 56px;
  }
  
  .track-row td {
    padding: 8px 12px;
  }

  .index-col { 
    width: 50px;
    padding-left: 12px !important;
  }

  .title-col {
    width: 68%;
    min-width: 150px;
  }

  .duration-col { 
    width: 100px;
    padding-right: 20px !important;
  }

  .title-wrapper {
    gap: 10px;
  }

  .title-wrapper img,
  .mini-placeholder {
    width: 40px;
    height: 40px;
  }

  .track-name {
    font-size: 14px;
  }

  .artists {
    font-size: 12px;
  }

  .duration {
    font-size: 13px;
    min-width: 35px;
  }

  .like-btn {
    padding: 6px;
  }
}

/* ===== MOBILE RESPONSIVENESS (480px and below) ===== */
@media (max-width: 480px) {
  .likedsongs-header {
    padding: 30px 16px 20px;
  }

  .likedsongs-cover-shadow {
    width: 140px;
    height: 140px;
  }

  .likedsongs-cover {
    width: 120px;
    height: 120px;
  }
  
  .likedsongs-cover svg {
    width: 48px;
    height: 48px;
  }

  .play-button-large {
    width: 56px;
    height: 56px;
  }
  
  .play-button-large svg {
    width: 24px;
    height: 24px;
  }

  .likedsongs-controls {
    padding: 20px 16px;
  }

  .likedsongs-tracks {
    margin: 0 12px;
  }

  .tracks-table th {
    padding: 10px 8px;
    font-size: 9px;
  }

  .track-row {
    height: 52px;
  }
  
  .track-row td {
    padding: 6px 8px;
  }

  .index-col { 
    width: 40px;
    padding-left: 8px !important;
  }

  .title-col {
    min-width: 120px;
  }

  .duration-col { 
    width: 85px;
    padding-right: 16px !important;
  }

  .title-wrapper {
    gap: 8px;
  }

  .title-wrapper img,
  .mini-placeholder {
    width: 36px;
    height: 36px;
  }

  .mini-placeholder {
    font-size: 16px;
  }

  .track-name {
    font-size: 13px;
    margin-bottom: 2px;
  }

  .artists {
    font-size: 11px;
  }

  .duration {
    font-size: 12px;
    min-width: 32px;
  }

  .duration-col {
    gap: 8px;
  }

  .like-btn {
    padding: 4px;
  }
  
  .like-btn svg {
    width: 14px;
    height: 14px;
  }

  .track-index {
    font-size: 13px;
  }

  .play-pause-btn svg {
    width: 14px;
    height: 14px;
  }

  .loading-message,
  .empty-message {
    padding: 60px 16px;
    font-size: 14px;
  }
}

/* ===== EXTRA SMALL MOBILE (380px and below) ===== */
@media (max-width: 380px) {
  .index-col { 
    width: 35px;
    padding-left: 6px !important;
  }

  .title-col {
    min-width: 100px;
  }

  .duration-col { 
    width: 75px;
    padding-right: 12px !important;
    gap: 6px;
  }

  .title-wrapper img,
  .mini-placeholder {
    width: 32px;
    height: 32px;
  }

  .track-name {
    font-size: 12px;
  }

  .artists {
    font-size: 10px;
  }

  .duration {
    font-size: 11px;
    min-width: 28px;
  }

  .like-btn svg {
    width: 12px;
    height: 12px;
  }
}
</file>

<file path="src/components/userdetails/LikedSongs.jsx">
// import React, { useState, useEffect } from 'react';
// import './LikedSongs.css';
// import { getPlaylistTracks, playTrack, likeTrack, unlikeTrack, checkTracksLiked } from '../../api/spotify';
// import { Play, Pause, Heart, MoreHorizontal, Clock } from 'lucide-react';

// export default function LikedSongs({ 
//   currentTrack, 
//   isPlaying, 
//   togglePlayback,
//   likedTrackIds = new Set()
// }) {
//   const [tracks, setTracks] = useState([]);
//   const [loading, setLoading] = useState(true);
//   const [hoveredIndex, setHoveredIndex] = useState(null);
//   const [likedStatus, setLikedStatus] = useState({});
//   const [loadingLiked, setLoadingLiked] = useState(true);

//   useEffect(() => {
//     const loadLikedSongs = async () => {
//       setLoading(true);
//       try {
//         const data = await getPlaylistTracks('liked-songs');
//         setTracks(data.items || []);
//       } catch (err) {
//         console.error('Failed to load Liked Songs:', err);
//       } finally {
//         setLoading(false);
//       }
//     };

//     loadLikedSongs();
//   }, []);

//   const formatDuration = (ms) => {
//     const minutes = Math.floor(ms / 60000);
//     const seconds = ((ms % 60000) / 1000).toFixed(0);
//     return `${minutes}:${seconds.padStart(2, '0')}`;
//   };

//   const handlePlayTrack = async (track) => {
//     try {
//         await playTrack(track.id);
//     } catch (error) {
//         console.error("Error playing track:", error);
//     }    
//   };
  
//     useEffect(() => {
        
//       if (tracks?.track || tracks.length === 0) {
//         setLikedStatus({});
//         setLoadingLiked(false);
//         return;
//       }
  
//       async function checkLikedForAllTracks() {
//         try {
//           const allTrackIds = tracks
//             .map((item) => item.track.id)
//             .filter((id) => id != null);
  
//           if (tracks.length === 0) {
//             setLikedStatus({});
//             setLoadingLiked(false);
//             return;
//           }
  
//           const batches = [];
//           for (let i = 0; i < allTrackIds.length; i += 50) {
//             batches.push(allTrackIds.slice(i, i + 50));
//           }
  
//           const batchResults = await Promise.all(
//             batches.map((batch) => checkTracksLiked(batch))
//           );
  
//           const statusMap = {};
//           let index = 0;
//           batchResults.forEach((batch) => {
//             batch.forEach((isLiked) => {
//               statusMap[allTrackIds[index]] = isLiked;
//               index++;
//             });
//           });
  
//           setLikedStatus(statusMap);
//         } catch (err) {
//           console.error("Failed to check liked status for playlist tracks:", err);
//           setLikedStatus({});
//         } finally {
//           setLoadingLiked(false);
//         }
//       }
  
//       checkLikedForAllTracks();
//     }, [tracks]);
  
//     const handleLikeToggle = async (trackId) => {  
//       const currentLiked = likedStatus[trackId] || false;
  
//       try {
//         if (currentLiked) {
//           await unlikeTrack(trackId);
//         } else {
//           await likeTrack(trackId);
//         }
  
//         setLikedStatus((prev) => ({
//           ...prev,
//           [trackId]: !currentLiked,
//         }));
//       } catch (err) {
//         console.error("Failed to toggle like:", err);
//         alert("Could not update like status. Try again.");
//       }
//     };

//   const isCurrentTrack = (trackId) => currentTrack?.id === trackId;

//   return (
//     <div className="likedsongs-view">
//       <div className="likedsongs-header">
//         <div className="likedsongs-cover-shadow">
//           <div className="likedsongs-cover">
//             <Heart size={80} fill="#1ed760" stroke="#1ed760" />
//           </div>
//         </div>

//         <div className="likedsongs-info">
//           <span className="playlist-badge">Playlist</span>
//           <h1 className="likedsongs-title">Liked Songs</h1>
//           <p className="likedsongs-description">
//             {tracks.length > 0 ? `${tracks.length} songs you've liked` : 'Your favorite tracks'}
//           </p>
//         </div>
//       </div>

//       <div className="likedsongs-controls">
//         <button className="play-button-large" aria-label="Play all">
//           <Play size={28} fill="black" />
//         </button>
//         <button className="more-button" aria-label="More options">
//           <MoreHorizontal size={32} />
//         </button>
//       </div>

//       <div className="likedsongs-tracks">
//         <table className="tracks-table">
//           <thead>
//             <tr>
//               <th className="index-col">#</th>
//               <th>Title</th>
//               <th className="album-col">Album</th>
//               <th className="duration-col">
//                 <Clock size={16} />
//               </th>
//             </tr>
//           </thead>
//           <tbody>
//             {loading ? (
//               <tr>
//                 <td colSpan="4" className="loading-message">Loading your liked songs...</td>
//               </tr>
//             ) : tracks.length === 0 ? (
//               <tr>
//                 <td colSpan="4" className="empty-message">
//                   No liked songs yet. Start adding some! â¤ï¸
//                 </td>
//               </tr>
//             ) : (
//               tracks.map((item, index) => {
//                 const track = item.track;
//                 const isHovered = hoveredIndex === index;
//                 const isCurrentlyPlaying = isCurrentTrack(track.id);
//                 const isLiked = likedStatus[track.id] || false;
//                 const isLoadingThisTrack = loadingLiked && likedStatus[track.id] === undefined;

//                 return (
//                   <tr
//                     key={track.id}
//                     className={`track-row ${isCurrentlyPlaying ? 'playing' : ''}`}
//                     onMouseEnter={() => setHoveredIndex(index)}
//                     onMouseLeave={() => setHoveredIndex(null)}
//                   >
//                     <td className="index-col">
//                       {isHovered || isCurrentlyPlaying ? (
//                         <button
//                           className="play-pause-btn"
//                           onClick={() => 
//                             isCurrentlyPlaying ? togglePlayback() : handlePlayTrack(track, index)
//                           }
//                           aria-label={isCurrentlyPlaying && isPlaying ? 'Pause' : 'Play'}
//                         >
//                           {isCurrentlyPlaying && isPlaying ? (
//                             <Pause size={16} />
//                           ) : (
//                             <Play size={16} fill="white" />
//                           )}
//                         </button>
//                       ) : (
//                         <span className="track-index">{index + 1}</span>
//                       )}
//                     </td>

//                     <td className="title-col">
//                       <div className="title-wrapper">
//                         {track.album.images?.[2]?.url ? (
//                           <img src={track.album.images[2].url} alt={track.album.name} />
//                         ) : (
//                           <div className="mini-placeholder">â™ª</div>
//                         )}
//                         <div>
//                           <div className={`track-name ${isCurrentlyPlaying ? 'now-playing' : ''}`}>
//                             {track.name}
//                           </div>
//                           <div className="artists">
//                             {track.artists.map(a => a.name).join(', ')}
//                           </div>
//                         </div>
//                       </div>
//                     </td>

//                     <td className="album-col">{track.album.name}</td>

//                     <td className="duration-col">
//                       <span className="duration">{formatDuration(track.duration_ms)}</span>
//                       <button
//                         className="like-btn"
//                         onClick={() => handleLikeToggle(track.id)}
//                         aria-label={likedTrackIds.has(track.id) ? 'Unlike song' : 'Like song'}
//                       >
//                         <Heart
//                           size={16}
//                           disabled={isLoadingThisTrack}
//                           fill={isLiked ? '#1ed760' : 'none'}
//                           stroke={isLiked ? "#1db954" : "#b3b3b3"}
//                           style={{ cursor: isLoadingThisTrack ? "wait" : "pointer" }}
//                         />
//                       </button>
//                     </td>
//                   </tr>
//                 );
//               })
//             )}
//           </tbody>
//         </table>
//       </div>
//     </div>
//   );
// }

import React, { useState, useEffect } from 'react';
import './LikedSongs.css';
import { getPlaylistTracks, playTrack, likeTrack, unlikeTrack, checkTracksLiked } from '../../api/spotify';
import { Play, Pause, Heart, MoreHorizontal, Clock } from 'lucide-react';

export default function LikedSongs({ 
  currentTrack, 
  isPlaying, 
  togglePlayback,
  // likedTrackIds = new Set()
}) {
  const [tracks, setTracks] = useState([]);
  const [loading, setLoading] = useState(true);
  const [hoveredIndex, setHoveredIndex] = useState(null);
  const [likedStatus, setLikedStatus] = useState({});
  const [loadingLiked, setLoadingLiked] = useState(true);

  useEffect(() => {
    const loadLikedSongs = async () => {
      setLoading(true);
      try {
        const data = await getPlaylistTracks('liked-songs');
        setTracks(data.items || []);
      } catch (err) {
        console.error('Failed to load Liked Songs:', err);
      } finally {
        setLoading(false);
      }
    };

    loadLikedSongs();
  }, []);

  const formatDuration = (ms) => {
    const minutes = Math.floor(ms / 60000);
    const seconds = ((ms % 60000) / 1000).toFixed(0);
    return `${minutes}:${seconds.padStart(2, '0')}`;
  };

  const handlePlayTrack = async (track) => {
    try {
        await playTrack(track.id);
    } catch (error) {
        console.error("Error playing track:", error);
    }    
  };
  
  useEffect(() => {
    if (tracks?.track || tracks.length === 0) {
      setLikedStatus({});
      setLoadingLiked(false);
      return;
    }

    async function checkLikedForAllTracks() {
      try {
        const allTrackIds = tracks
          .map((item) => item.track.id)
          .filter((id) => id != null);

        if (tracks.length === 0) {
          setLikedStatus({});
          setLoadingLiked(false);
          return;
        }

        const batches = [];
        for (let i = 0; i < allTrackIds.length; i += 50) {
          batches.push(allTrackIds.slice(i, i + 50));
        }

        const batchResults = await Promise.all(
          batches.map((batch) => checkTracksLiked(batch))
        );

        const statusMap = {};
        let index = 0;
        batchResults.forEach((batch) => {
          batch.forEach((isLiked) => {
            statusMap[allTrackIds[index]] = isLiked;
            index++;
          });
        });

        setLikedStatus(statusMap);
      } catch (err) {
        console.error("Failed to check liked status for playlist tracks:", err);
        setLikedStatus({});
      } finally {
        setLoadingLiked(false);
      }
    }

    checkLikedForAllTracks();
  }, [tracks]);

  const handleLikeToggle = async (trackId) => {  
    const currentLiked = likedStatus[trackId] || false;

    try {
      if (currentLiked) {
        await unlikeTrack(trackId);
      } else {
        await likeTrack(trackId);
      }

      setLikedStatus((prev) => ({
        ...prev,
        [trackId]: !currentLiked,
      }));
    } catch (err) {
      console.error("Failed to toggle like:", err);
      alert("Could not update like status. Try again.");
    }
  };

  const isCurrentTrack = (trackId) => currentTrack?.id === trackId;

  return (
    <div className="likedsongs-view">
      <div className="likedsongs-header">
        <div className="likedsongs-cover-shadow">
          <div className="likedsongs-cover">
            <Heart size={80} fill="#1ed760" stroke="#1ed760" />
          </div>
        </div>

        <div className="likedsongs-info">
          <span className="playlist-badge">Playlist</span>
          <h1 className="likedsongs-title">Liked Songs</h1>
          <p className="likedsongs-description">
            {tracks.length > 0 ? `${tracks.length} songs you've liked` : 'Your favorite tracks'}
          </p>
        </div>
      </div>

      <div className="likedsongs-controls">
        <button className="play-button-large" aria-label="Play all">
          <Play size={28} fill="black" />
        </button>
        <button className="more-button" aria-label="More options">
          <MoreHorizontal size={32} />
        </button>
      </div>

      <div className="likedsongs-tracks">
        <table className="tracks-table">
          <thead>
            <tr>
              <th className="index-col">#</th>
              <th className="title-col">Title</th>
              <th className="album-col">Album</th>
              <th className="duration-col">
                <Clock size={16} />
              </th>
            </tr>
          </thead>
          <tbody>
            {loading ? (
              <tr>
                <td colSpan="4" className="loading-message">Loading your liked songs...</td>
              </tr>
            ) : tracks.length === 0 ? (
              <tr>
                <td colSpan="4" className="empty-message">
                  No liked songs yet. Start adding some! â¤ï¸
                </td>
              </tr>
            ) : (
              tracks.map((item, index) => {
                const track = item.track;
                const isHovered = hoveredIndex === index;
                const isCurrentlyPlaying = isCurrentTrack(track.id);
                const isLiked = likedStatus[track.id] || false;
                const isLoadingThisTrack = loadingLiked && likedStatus[track.id] === undefined;

                return (
                  <tr
                    key={track.id}
                    className={`track-row ${isCurrentlyPlaying ? 'playing' : ''}`}
                    onMouseEnter={() => setHoveredIndex(index)}
                    onMouseLeave={() => setHoveredIndex(null)}
                  >
                    {/* Column 1: Index/Play Button */}
                    <td className="index-col">
                      {isHovered || isCurrentlyPlaying ? (
                        <button
                          className="play-pause-btn"
                          onClick={() => 
                            isCurrentlyPlaying ? togglePlayback() : handlePlayTrack(track, index)
                          }
                          aria-label={isCurrentlyPlaying && isPlaying ? 'Pause' : 'Play'}
                        >
                          {isCurrentlyPlaying && isPlaying ? (
                            <Pause size={16} />
                          ) : (
                            <Play size={16} fill="white" />
                          )}
                        </button>
                      ) : (
                        <span className="track-index">{index + 1}</span>
                      )}
                    </td>

                    {/* Column 2: Title */}
                    <td className="title-col">
                      <div className="title-wrapper">
                        {track.album.images?.[2]?.url ? (
                          <img src={track.album.images[2].url} alt={track.album.name} />
                        ) : (
                          <div className="mini-placeholder">â™ª</div>
                        )}
                        <div>
                          <div className={`track-name ${isCurrentlyPlaying ? 'now-playing' : ''}`}>
                            {track.name}
                          </div>
                          <div className="artists">
                            {track.artists.map(a => a.name).join(', ')}
                          </div>
                        </div>
                      </div>
                    </td>

                    {/* Column 3: Album (hidden on mobile) */}
                    <td className="album-col">{track.album.name}</td>

                    {/* Column 4: Duration */}
                    <td className="duration-col">
                      <span className="duration">{formatDuration(track.duration_ms)}</span>
                      <button
                        className="like-btn"
                        onClick={() => handleLikeToggle(track.id)}
                        aria-label={isLiked ? 'Unlike song' : 'Like song'}
                      >
                        <Heart
                          size={16}
                          disabled={isLoadingThisTrack}
                          fill={isLiked ? '#1ed760' : 'none'}
                          stroke={isLiked ? "#1db954" : "#b3b3b3"}
                          style={{ cursor: isLoadingThisTrack ? "wait" : "pointer" }}
                        />
                      </button>
                    </td>
                  </tr>
                );
              })
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}
</file>

<file path="src/components/userdetails/Playlist.jsx">
import { useEffect, useState } from 'react';
import { getUserPlaylists, setAuthToken } from '../../api/spotify';

export default function Playlist({ accessToken, children }) {
  const [playlists, setPlaylists] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!accessToken) return;

    setAuthToken(accessToken);

    const fetchPlaylists = async () => {
      try {
        const data = await getUserPlaylists();
        setPlaylists(data);
      } catch (err) {
        setError(err?.response?.data?.error?.message || err.message || 'Failed to load playlists');
      } finally {
        setLoading(false);
      }
    };

    fetchPlaylists();
  }, [accessToken]);

  if (loading) return null;
  if (error) return null;


  return children(playlists);
}
</file>

<file path="src/components/userdetails/PlayListView.jsx">
import React, { useState, useEffect } from "react";
import "../maincontent/MainContent.css";
import { Play, Heart } from "lucide-react";
import { playTrack, likeTrack, unlikeTrack, checkTracksLiked } from "../../api/spotify";

export default function PlaylistView({ playlist }) {
  const [likedStatus, setLikedStatus] = useState({});
  const [loadingLiked, setLoadingLiked] = useState(true);
  
  useEffect(() => {
    if (!playlist?.tracks?.items || playlist.tracks.items.length === 0) {
      setLikedStatus({});
      setLoadingLiked(false);
      return;
    }

    async function checkLikedForAllTracks() {
      try {
        const trackItems = playlist.tracks.items;
        const allTrackIds = trackItems
          .map((item) => item.track?.id)
          .filter((id) => id != null);

        if (allTrackIds.length === 0) {
          setLikedStatus({});
          setLoadingLiked(false);
          return;
        }

        const batches = [];
        for (let i = 0; i < allTrackIds.length; i += 50) {
          batches.push(allTrackIds.slice(i, i + 50));
        }

        const batchResults = await Promise.all(
          batches.map((batch) => checkTracksLiked(batch))
        );

        const statusMap = {};
        let index = 0;
        batchResults.forEach((batch) => {
          batch.forEach((isLiked) => {
            statusMap[allTrackIds[index]] = isLiked;
            index++;
          });
        });

        setLikedStatus(statusMap);
      } catch (err) {
        console.error("Failed to check liked status for playlist tracks:", err);
        setLikedStatus({});
      } finally {
        setLoadingLiked(false);
      }
    }

    checkLikedForAllTracks();
  }, [playlist?.tracks?.items]);

  const handleLikeToggle = async (trackId, e) => {
    e.stopPropagation();

    const currentLiked = likedStatus[trackId] || false;

    try {
      if (currentLiked) {
        await unlikeTrack(trackId);
      } else {
        await likeTrack(trackId);
      }

      setLikedStatus((prev) => ({
        ...prev,
        [trackId]: !currentLiked,
      }));
    } catch (err) {
      console.error("Failed to toggle like:", err);
      alert("Could not update like status. Try again.");
    }
  };

  const handleClicked = async (trackUri) => {
    try {
      const trackId = trackUri.split(":").pop();
      await playTrack(trackId);
    } catch (error) {
      console.error("Error playing track:", error);
    }
  };

  if (!playlist) {
    return <div className="loading">Loading tracks...</div>;
  }

  if (!playlist.tracks?.items?.length) {
    return <div className="loading">No tracks found</div>;
  }

  return (
    <div className="playlist-tracks">
      {(playlist.tracks?.items || playlist || []).map((item, index) => {
        const track = item.track;
        if (!track) return null;

        const isLiked = likedStatus[track.id] || false;
        const isLoadingThisTrack = loadingLiked && likedStatus[track.id] === undefined;

        const minutes = Math.floor(track.duration_ms / 60000);
        const seconds = Math.floor((track.duration_ms % 60000) / 1000)
          .toString()
          .padStart(2, "0");

        return (
          <div
            key={track.id}
            className="song-row"
            onClick={() => handleClicked(track.uri)}
          >
            {/* Column 1: Number/Play Icon - matches header-numberr (50px) */}
            <div className="song-number">
              <span className="number-text">{index + 1}</span>
              <Play className="play-icon" fill="white" size={16} />
            </div>

            {/* Column 2: Title - matches header-titlee (1fr) */}
            <div className="song-info">
              <div className="song-thumbnail">
                <img
                  src={track.album.images[2]?.url || "/default-album.png"}
                  alt={track.name}
                />
              </div>
              <div className="song-details">
                <div className="song-title">{track.name}</div>
                <div className="song-artist">
                  {track.artists.map((a) => a.name).join(", ")}
                </div>
              </div>
            </div>

            {/* Column 3: Album - matches header-albumm (1fr) */}
            <div className="song-album">{track.album.name}</div>

            {/* Column 4: Duration - matches header-durationn (80px) */}
            <div className="song-duration">
              <Heart
                className="heart-icon"
                onClick={(e) => handleLikeToggle(track.id, e)}
                disabled={isLoadingThisTrack}
                fill={isLiked ? "#1db954" : "none"}
                stroke={isLiked ? "#1db954" : "#b3b3b3"}
                size={18}
                style={{ cursor: isLoadingThisTrack ? "wait" : "pointer" }}
              />
              <span className="duration-text">{minutes}:{seconds}</span>
            </div>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="src/index.css">

</file>

<file path="src/main.jsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="vercel.json">
{
  "version": 2,
  "builds": [
    {
      "src": "api/index.js",
      "use": "@vercel/node"
    },
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "dist"
      }
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/index.js"
    },
    {
      "src": "/auth/(.*)",
      "dest": "/api/index.js"
    },
    {
      "src": "/(.*)",
      "dest": "/index.html"
    }
  ]
}
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      // Proxy all /api and /auth requests to your backend
      '/api': {
        target: 'http://127.0.0.1:5000',
        changeOrigin: true,
        secure: false,
      },
      '/auth': {
        target: 'http://127.0.0.1:5000',
        changeOrigin: true,
        secure: false,
      },
    },
  },
})
</file>

</files>
